(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function () {
    'use strict';

    var Extendable = require('./extendable');

    module.exports = (function() {
        // Inherit from the Extendable class
        Extendable.extend(Component);

        // The entity that is assigned this component
        Component.prototype.entity = {};

        // The name to refer to this component
        Component.prototype.name = 'Component';
        Component.title = 'Component';

        function Component(entity) {
            this.entity = entity;
        }

        // Functions called when the entity receives the given event
        Component.prototype.respondEvents = {};

        return Component;

    })();
})();

},{"./extendable":15}],2:[function(require,module,exports){
/*
    Component: Bounded
    Prevents moving outside the canvas
*/
(function () {
    'use strict';

    var Component = require('../component');

    module.exports = (function() {
        // Inherit from the Component class
        Component.extend(Bounded);

        // The name to refer to this component
        Bounded.prototype.name = 'Bounded';
        Bounded.title = 'Bounded';

        // The location to be bounded within
        Bounded.prototype.x = null;
        Bounded.prototype.y = null;
        Bounded.prototype.width = null;
        Bounded.prototype.height = null;

        function Bounded(entity, x, y, width, height) {
            if (x !== null) {
                this.x = x;
            }
            if (y !== null) {
                this.y = y;
            }
            if (width !== null) {
                this.width = width;
            }
            if (height !== null) {
                this.height = height;
            }

            Bounded.__super__.constructor.call(this, entity);
        }

        Bounded.prototype.preRender = function(event, scene) {
            // If no args passed, bound inside whole canvas
            if (this.x === null) {
                this.x = 0;
            }
            if (this.y === null) {
                this.y = 0;
            }
            if (this.width === null) {
                this.width = scene.ctx.canvas.width;
            }
            if (this.height === null) {
                this.height = scene.ctx.canvas.height;
            }

            // North Edge
            if (this.entity.y < this.y) {
                this.entity.y = this.y;
            }

            // East Edge
            if (this.entity.x + this.entity.width > this.x + this.width) {
                this.entity.x = this.x + this.width - this.entity.width;
            }

            // South Edge
            if (this.entity.y + this.entity.height > this.y + this.height) {
                this.entity.y = this.height - this.y - this.entity.height;
            }

            // West Edge
            if (this.entity.x < this.x) {
                this.entity.x = this.x;
            }
        };

        return Bounded;

    })();
})();

},{"../component":1}],3:[function(require,module,exports){
/*
    Component: Collision
    Calls a callback when colliding with another entity
*/
(function () {
    'use strict';

    var Scene = require('../scene');
    var Component = require('../component');

    module.exports = (function() {
        // Inherit from the Component class
        Component.extend(Collision);

        // The name to refer to this component
        Collision.prototype.name = 'Collision';
        Collision.title = 'Collision';

        // The function to call if a collision was detected
        Collision.prototype.callback = null;

        // The event to listen to and check for a collision
        Collision.prototype.eventName = 'preRender';

        // The component on other entities that can be collided with
        // If none given, all can be collided with
        Collision.prototype.componentCollidable = null;

        function Collision(entity, componentCollidable, callback, eventName) {
            this.entity = entity;
            this.componentCollidable = componentCollidable;
            this.callback = callback;
            if (eventName !== null) {
                this.eventName = eventName;
            }

            Collision.__super__.constructor.call(this, entity);
        }

        Collision.prototype.preRender = function(event, scene) {
            if (this.eventName === event.type) {
                this.check(event, scene);
            }
        };

        Collision.prototype.mouseup = function(event, scene) {
            if (this.eventName === event.type) {
                this.check(event, scene);
            }
        };

        Collision.prototype.mousedown = function(event, scene) {
            if (this.eventName === event.type) {
                this.check(event, scene);
            }
        };

        Collision.prototype.mousemove = function(event, scene) {
            if (this.eventName === event.type) {
                this.check(event, scene);
            }
        };

        // Check for a collision and act
        Collision.prototype.check = function(event, scene) {
            // Can't collide with a hidden entity
            if (this.entity.display) {
                // Loop through all entities
                for (var i in scene.entities) {
                    var entity = scene.entities[i];

                    // Do we care if these entities overlap?
                    if ((this.entity !== entity) && entity.display && ((this.componentCollidable === null) || (this.componentCollidable in entity.components))) {
                        // Check if the entities overlap
                        if (Scene.isOverlap(this.entity, entity)) {
                            // Call the callback!
                            this.callback(event, scene, entity);
                        }
                    }
                }
            }
        };

        return Collision;

    })();
})();

},{"../component":1,"../scene":17}],4:[function(require,module,exports){
/*
    Component: DragCreate
    On drag, creates a new draggable entity and drags it
    Ala getting something from a toolbar
*/
(function () {
    'use strict';

    var Scene = require('../scene');
    var Component = require('../component');

    module.exports = (function() {
        // Inherit from the Component class
        Component.extend(DragCreate);

        // The name to refer to this component
        DragCreate.prototype.name = 'DragCreate';
        DragCreate.title = 'DragCreate';

        // An entity to be created on drag, bound to its arguments
        // So could be passed as this for example: Entity.bind(this, 0, 0)
        DragCreate.prototype.EntityDragBind = null;

        // The callback to be called when an entity is created
        // Receives parameters event, scene, and entity
        DragCreate.prototype.callback = null;

        function DragCreate(entity, EntityDragBind, callback) {
            this.EntityDragBind = EntityDragBind;
            if (typeof callback !== 'undefined') {
                this.callback = callback;
            }

            DragCreate.__super__.constructor.call(this, entity);
        }

        DragCreate.prototype.touchstart = function(event, scene) {
            // Call event.preventDefault to prevent touchcancel if necessary
            if (Scene.isInside(scene.getEventCoords(event), this.entity) && this.entity.display && !scene.dragging) {
                event.preventDefault();
            }

            this.drag(event, scene);
        };

        DragCreate.prototype.mousedown = function(event, scene) {
            this.drag(event, scene);
        };

        DragCreate.prototype.drag = function(event, scene) {
            // Can't dragcreate hidden entities
            if (this.entity.display && !scene.dragging) {
                var coords = scene.getEventCoords(event);

                // Check to see if the entity was clicked
                if (Scene.isInside(coords, this.entity)) {
                    // Create the new entity
                    var dragging = scene.entityAdd(new this.EntityDragBind());
                    dragging.x = this.entity.x;
                    dragging.y = this.entity.y;
                    dragging.components.Draggable.draggingX = coords.x - this.entity.x;
                    dragging.components.Draggable.draggingY = coords.y - this.entity.y;

                    // Call the callback if given
                    if (this.callback !== null) {
                        this.callback(event, scene, this.entity, dragging);
                    }
                }
            }
        };

        return DragCreate;

    })();
})();

},{"../component":1,"../scene":17}],5:[function(require,module,exports){
/*
    Component: Draggable
    Makes the entity draggable with the mouse
*/
(function () {
    'use strict';
 
    var Scene = require('../scene');
    var Component = require('../component');

    module.exports = (function() {
        // Inherit from the Component class
        Component.extend(Draggable);

        // The name to refer to this component
        Draggable.prototype.name = 'Draggable';
        Draggable.title = 'Draggable';

        Draggable.prototype.draggingX = null;
        Draggable.prototype.draggingY = null;

        function Draggable(entity) {
            Draggable.__super__.constructor.call(this, entity);
        }

        Draggable.prototype.mousedown = function(event, scene) {
            this.dragStart(event, scene);
        };

        Draggable.prototype.touchstart = function(event, scene) {
            // Call event.preventDefault to prevent touchcancel if necessary
            if (Scene.isInside(scene.getEventCoords(event), this.entity) && this.isDragging()) {
                event.preventDefault();
            }

            this.dragStart(event, scene);
        };

        Draggable.prototype.mousemove = function(event, scene) {
            this.dragMove(event, scene);
        };

        Draggable.prototype.touchmove = function(event, scene) {
            this.dragMove(event, scene);
        };

        Draggable.prototype.mouseup = function(event, scene) {
            this.dragEnd(event, scene);
        };

        Draggable.prototype.touchend = function(event, scene) {
            this.dragEnd(event, scene);
        };

        Draggable.prototype.dragStart = function(event, scene) {
            if (scene.dragging === false) {
                var coords = scene.getEventCoords(event);

                // Check to see if the entity was clicked, and start dragging it if so
                if (Scene.isInside(coords, this.entity)) {
                    scene.dragging = true;
                    this.draggingX = coords.x - this.entity.x;
                    this.draggingY = coords.y - this.entity.y;
                }
            }
        };

        Draggable.prototype.dragMove = function(event, scene) {
            // Drag if needed
            if (this.isDragging()) {
                var coords = scene.getEventCoords(event);
                this.entity.x = coords.x - this.draggingX;
                this.entity.y = coords.y - this.draggingY;
            }
        };

        Draggable.prototype.dragEnd = function(event, scene) {
            // Release a drag if needed
            if (this.isDragging()) {
                scene.dragging = false;
                var coords = scene.getEventCoords(event);
                this.entity.x = coords.x - this.draggingX;
                this.entity.y = coords.y - this.draggingY;
                this.draggingX = null;
                this.draggingY = null;
            }
        };

        // Returns true if currently being dragged, false otherwise
        Draggable.prototype.isDragging = function() {
            if ((this.draggingX !== null) && (this.draggingY !== null)) {
                return true;
            }
            else {
                return false;
            }
        };

        return Draggable;

    })();
})();

},{"../component":1,"../scene":17}],6:[function(require,module,exports){
/*
    Component: keyMove
    Makes the entity movable with the keyboard, ala the player character
*/
(function () {
    'use strict';

    var Scene = require('../scene');
    var Component = require('../component');

    module.exports = (function() {
        // Inherit from the Component class
        Component.extend(Obj);

        // The name to refer to this component
        Obj.prototype.name = 'KeyMove';
        Obj.title = 'KeyMove';

        // Default
        Obj.prototype.speed = 100; // pixels / second

        // Keep track of which keys are pressed
        Obj.prototype.up = false;
        Obj.prototype.down = false;
        Obj.prototype.left = false;
        Obj.prototype.right = false;

        function Obj(entity, speed) {
            Obj.__super__.constructor.call(this, entity);

            if (typeof speed !== 'undefined' && speed !== null) {
                this.speed = speed;
            }
        }

        Obj.prototype.keydown = function(event, scene) {
            this.setKey(event.which, true);
        };

        Obj.prototype.keyup = function(event, scene) {
            this.setKey(event.which, false);
        };

        Obj.prototype.preRender = function(event, scene) {
            if (this.up) {
                this.entity.y -= this.speed * event.dt;
            }
            if (this.down) {
                this.entity.y += this.speed * event.dt;
            }
            if (this.left) {
                this.entity.x -= this.speed * event.dt;
            }
            if (this.right) {
                this.entity.x += this.speed * event.dt;
            }
        };

        Obj.prototype.setKey = function(which, pressed) {
            // Up (up arrow, w)
            if (which === 38 || which === 87) {
                this.up = pressed;
            }
            // Down (down arrow, s)
            if (which === 40 || which === 83) {
                this.down = pressed;
            }
            // Left (left arrow, a)
            if (which === 37 || which === 65) {
                this.left = pressed;
            }
            // Right (right arrow, d)
            if (which === 39 || which === 68) {
                this.right = pressed;
            }
        };

        return Obj;

    })();
})();

},{"../component":1,"../scene":17}],7:[function(require,module,exports){
/*
    Component: Tween
    Allows moving animations
*/
(function () {
    'use strict';

    var Component = require('../component');

    module.exports = (function() {
        // Inherit from the Component class
        Component.extend(Tween);

        // The name to refer to this component
        Tween.prototype.name = 'Tween';
        Tween.title = 'Tween';

        // Parameters
        Tween.prototype.x = null;
        Tween.prototype.y = null;
        Tween.prototype.callback = null;

        Tween.prototype.x0 = null;
        Tween.prototype.y0 = null;

        Tween.prototype.time = 0;
        Tween.prototype.duration = null;

        Tween.prototype.mx = null;
        Tween.prototype.my = null;

        function Tween(entity, x, y, speed, callback) {
            this.x = x;
            this.y = y;

            if (typeof callback !== 'undefined') {
                this.callback = callback;
            }

            // Save the original position
            this.x0 = entity.x;
            this.y0 = entity.y;

            // Calculate the distance between the two points
            var d = Math.pow(Math.pow(y - entity.y, 2) + Math.pow(x - entity.x, 2), 1/2);

            // Calculate the time to reach this point
            if (speed !== null) {
                this.duration = d / speed;
            }

            // Calculate the time slopes in x and y direcitons
            this.mx = (x - entity.x) / this.duration;
            this.my = (y - entity.y) / this.duration;

            Tween.__super__.constructor.call(this, entity);
        }

        Tween.prototype.preRender = function(event, scene) {
            if (this.time !== null && this.time < this.duration) {
                this.time += event.dt;

                // If we're done
                if (this.time >= this.duration) {
                    // Set the entity at its final place and reset the time attributes
                    this.entity.x = this.x;
                    this.entity.y = this.y;
                    this.time = null;

                    // Call the callback if needed
                    if (this.callback !== null) {
                        this.callback(event, this.entity);
                    }
                }
                // Otherwise move it move it
                else {
                    this.entity.x = this.x0 + this.mx * this.time;
                    this.entity.y = this.y0 + this.my * this.time;
                }
            }
        };

        return Tween;

    })();
})();

},{"../component":1}],8:[function(require,module,exports){
(function () {
    'use strict';

    var Scene = require('./scene');

    module.exports = (function() {

        // DOM Objects
        Engine.prototype.canvas = null;
        Engine.prototype.ctx = null;

        // Scenes
        Engine.prototype.scenes = {};
        Engine.prototype.sceneActive = null;
        Engine.prototype.changeScenesCallback = null;
        Engine.prototype.sceneChanging = false;

        function Engine(canvas, changeScenesCallback) {
            // Save the changeScenes callback if given
            if (typeof changeScenesCallback !== 'undefined' && changeScenesCallback !== null) {
                this.changeScenesCallback = changeScenesCallback;
            }

            // Reset scenes
            Engine.prototype.scenes = {};

            // Save the canvas and context
            this.canvas = canvas;
            this.ctx = this.canvas.getContext('2d');

            // Add event listeners
            var me = this;
            this.canvas.addEventListener('mousedown', function(event) {
                me.getSceneActive().eventFire(event);
            });
            this.canvas.addEventListener('mousemove', function(event) {
                me.getSceneActive().eventFire(event);
            });
            this.canvas.addEventListener('mouseup', function(event) {
                me.getSceneActive().eventFire(event);
            });
            this.canvas.addEventListener('click', function(event) {
                me.getSceneActive().eventFire(event);
            });
            this.canvas.addEventListener('touchstart', function(event) {
                me.getSceneActive().eventFire(event);
            });
            this.canvas.addEventListener('touchmove', function(event) {
                me.getSceneActive().eventFire(event);
            });
            this.canvas.addEventListener('touchend', function(event) {
                me.getSceneActive().eventFire(event);
            });
            document.addEventListener('keyup', function(event) {
                me.getSceneActive().eventFire(event);
            });
            document.addEventListener('keydown', function(event) {
                me.getSceneActive().eventFire(event);
            });
        }

        // Call at each frame
        Engine.prototype.render = function(dt) {
            // Render the current scene
            this.getSceneActive().render(this.ctx, dt);
        };

        // Create a new scene
        Engine.prototype.sceneAdd = function(scene, name) {
            this.scenes[name] = scene;
            // tongue twister
            this.scenes[name].name = name;
        };

        // Destroy a scene
        Engine.prototype.sceneDestroy = function(name) {
            delete this.scenes[name];
        };

        // Gets the active scene
        Engine.prototype.getSceneActive = function() {
            return this.scenes[this.sceneActive];
        };

        // Changes to the new scene
        Engine.prototype.changeScenes = function(sceneName, SceneType, preserveSelf) {
            // Only change scenes if a valid sceneName was given
            if (sceneName !== null && sceneName !== this.sceneActive && !this.sceneChanging) {
                var sceneCurrent = this.sceneActive;

                // If the scene doesn't already exist and SceneType was given, create it
                if (!this.scenes.hasOwnProperty(sceneName) && SceneType !== null) {
                    this.sceneAdd(new SceneType(this), sceneName);
                }

                // If everything went well, change scenes
                if (this.scenes.hasOwnProperty(sceneName)) {
                    this.sceneChanging = true;

                    var me = this;
                    // Wait 50ms to avoid 'flash' between scenes
                    window.setTimeout(function() {
                        me.sceneActive = sceneName;

                        // Destroy the current scene unless preserveSelf
                        if ((preserveSelf === null || !preserveSelf) && sceneCurrent !== null) {
                            me.scenes[sceneCurrent].destroy();
                        }

                        // Call the callback if it was given
                        if (me.changeScenesCallback !== null) {
                            me.changeScenesCallback(me.getSceneActive());
                        }

                        me.sceneChanging = false;
                    }, 50);
                }
            }
        };

        return Engine;
    })();
})();

},{"./scene":17}],9:[function(require,module,exports){
/*
    Entity: Text: Button
    Creates a text object with an outline around it
*/
(function () {
    'use strict';

    var Scene = require('../scene');
    var Text = require('../entities/text');

    module.exports = (function() {
        Text.extend(Button);

        Button.prototype.callback = null;
        Button.prototype.scene = null;
        Button.prototype.height = null;
        Button.prototype.padding = 16;
        Button.prototype.strokeStyle = 'rgb(0, 0, 0)';

        function Button(x, y, width, height, text, font, fillStyle, callback, padding, strokeStyle) {
            Button.__super__.constructor.call(this, x, y, width, text, font, fillStyle);

            // Necessary to pass in parameters
            this.callback = callback;
            this.height = height;

            // Optional parameters
            if (typeof padding !== 'undefined') {
                this.padding = padding;
            }
            if (typeof strokeStyle !== 'undefined') {
                this.strokeStyle = strokeStyle;
            }
        }

        Button.prototype.render = function(ctx, dt) {
            // Draw the rectangle
            ctx.strokeStyle = this.strokeStyle;
            ctx.strokeRect(this.x, this.y, this.width, this.height);

            // Get the height of the font
            var fontSize = parseInt(this.font.substr(0, this.font.indexOf('px')));

            // Draw the text
            if (this.font !== null) {
                ctx.font = this.font;
            }
            ctx.fillStyle = this.fillStyle;
            ctx.fillText(this.text, this.x + this.padding, this.y + fontSize + this.padding, this.width - this.padding * 2);
        };

        // Button click event, has to check if click was inside the button!
        Button.prototype.click = function(event, scene) {
            if (Scene.isInside(scene.getEventCoords(event), this) && this.display) {
                this.callback(event);
            }
        };

        return Button;

    })();
})();

},{"../entities/text":11,"../scene":17}],10:[function(require,module,exports){
(function () {
    'use strict';

    var Entity = require('../entity');

    module.exports = (function() {
        Entity.extend(Sprite);

        Sprite.prototype.obj = null;

        // Sprite
        Sprite.prototype.spriteSheet = null;
        Sprite.prototype.spriteX = 0;
        Sprite.prototype.spriteY = 0;
        Sprite.prototype.spriteXDefault = 0;
        Sprite.prototype.spriteYDefault = 0;
        Sprite.prototype.loading = false;

        // Animation
        Sprite.prototype.spriteAnimations = {};
        Sprite.prototype.spriteAnimation = null;
        Sprite.prototype.spriteAnimationTime = null;
        Sprite.prototype.spriteAnimationCallback = null;

        function Sprite(x, y, width, height, spriteSheet, spriteX, spriteY, spriteWidth, spriteHeight) {
            Sprite.__super__.constructor.call(this, x, y, width, height);

            this.spriteSheet = spriteSheet;

            if (typeof spriteX === 'undefined' || spriteX === null) {
                this.spriteX = 0;
            }
            else {
                this.spriteX = spriteX;
            }
            if (typeof spriteY === 'undefined' || spriteY === null) {
                this.spriteY = 0;
            }
            else {
                this.spriteY = spriteY;
            }
            if (typeof spriteWidth === 'undefined' || spriteWidth === null) {
                this.spriteWidth = width;
            }
            else {
                this.spriteWidth = spriteWidth;
            }
            if (typeof spriteHeight === 'undefined' || spriteHeight === null) {
                this.spriteHeight = height;
            }
            else {
                this.spriteHeight = spriteHeight;
            }

            this.spriteXDefault = this.spriteX;
            this.spriteYDefault = this.spriteY;

            // Create the object
            this.obj = new Image();

            // Load it's resource
            var me = this;
            this.obj.addEventListener('load', function() {
                me.loading = false;
            }, false);
            this.obj.src = this.spriteSheet;
            this.loading = true;

            // Reset objects (for a deep copy)
            this.spriteAnimations = {};
        }

        // Draw the entity in the given context at the given coordinates
        Sprite.prototype.render = function(ctx, dt) {
            if (!this.loading) {
                // Handle sprite animations if needed for next frame
                if (this.spriteAnimation !== null) {
                    this.spriteAnimationTime += dt;
                    var animation = this.spriteAnimations[this.spriteAnimation];
                    var framesLength = animation.toX - animation.fromX + 1;

                    // If the animation has ended...
                    if (this.spriteAnimationTime > animation.period * framesLength) {
                        // If we have a set number of repetitions
                        if (this.spriteAnimationRepetitions > 0) {
                            this.spriteAnimationRepetitions--;
                            // If we've finished animating
                            if (this.spriteAnimationRepetitions === 0) {
                                // Call the callback if needed
                                if (this.spriteAnimationCallback !== null) {
                                    this.spriteAnimationCallback({type: 'spriteAnimationEnd'}, this);
                                }

                                // Reset parameters
                                this.spriteAnimation = null;
                                this.spriteAnimationTime = null;
                                this.spriteAnimationCallback = null;
                                this.spriteX = this.spriteXDefault;
                                this.spriteY = this.spriteYDefault;
                            }
                            // Otherwise reset the animation
                            else {
                                this.spriteAnimationTime = 0;
                            }
                        }
                        else {
                            this.spriteAnimationTime = 0;
                        }
                    }
                    // Otherwise make sure the current frame is correct
                    else {
                        var frame = Math.floor(this.spriteAnimationTime / animation.period);
                        this.spriteX = animation.fromX + frame;
                        this.spriteY = animation.fromY;
                    }
                }

                // Render the image on the scene
                if (this.display) {
                    var image = this.obj;
                    var sx = this.spriteX * this.spriteWidth;
                    var sy = this.spriteY * this.spriteHeight;
                    var sWidth = this.spriteWidth;
                    var sHeight = this.spriteHeight;
                    var dx = this.x;
                    var dy = this.y;
                    var dWidth = this.width;
                    var dHeight = this.height;
                    ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
                }
            }
        };

        // Define a new sprite animation with the given names and frames in the sprite sheet
        Sprite.prototype.spriteAnimationAdd = function(name, fromX, fromY, toX, period) {
            this.spriteAnimations[name] = {fromX: fromX, fromY: fromY, toX: toX, period: period};
        };

        // Run an animation
        Sprite.prototype.spriteAnimate = function(name, repetitions, callback) {
            if (typeof callback !== 'undefined') {
                this.spriteAnimationCallback = callback;
            }
            if (repetitions === null) {
                repetitions = -1;
            }
            this.spriteAnimationRepetitions = repetitions;
            this.spriteAnimation = name;
            this.spriteAnimationTime = 0;
        };

        // Stop the running animation
        Sprite.prototype.spriteAnimateStop = function() {
            this.spriteAnimation = null;
            this.spriteAnimationTime = null;
            this.spriteX = this.spriteXDefault;
            this.spriteY = this.spriteYDefault;
        };

        return Sprite;

    })();
})();

},{"../entity":14}],11:[function(require,module,exports){
/*
    Entity: Text
    Creates a text object
*/
(function () {
    'use strict';

    var Entity = require('../entity');

    module.exports = (function() {
        Entity.extend(Text);

        Text.prototype.text = '';
        Text.prototype.font = null;
        Text.prototype.fillStyle = 'rgb(0, 0, 0)';
        Text.prototype.textAlign = 'left';

        function Text(x, y, width, text, font, fillStyle, textAlign) {
            if (typeof text !== 'undefined') {
                this.text = text;
            }
            if (typeof font !== 'undefined') {
                this.font = font;
            }
            if (typeof fillStyle !== 'undefined') {
                this.fillStyle = fillStyle;
            }
            if (typeof textAlign !== 'undefined') {
                this.textAlign = textAlign;
            }
            Text.__super__.constructor.call(this, x, y, width, this.height || 0);
        }

        Text.prototype.render = function(ctx, dt) {
            if (this.font !== null) {
                ctx.font = this.font;
            }
            ctx.textAlign = this.textAlign;
            ctx.fillStyle = this.fillStyle;

            ctx.fillText(this.text, this.x, this.y, this.width);
        };

        return Text;

    })();
})();

},{"../entity":14}],12:[function(require,module,exports){
/*
    Entity: Text: TextInput
    Mimics an <input> in DOM
*/
(function () {
    'use strict';

    var Text = require('./text');
    var Scene = require('../scene');

    module.exports = (function() {
        Text.extend(TextInput);

        TextInput.prototype.height = 0;
        TextInput.prototype.font = null;
        TextInput.prototype.fillStyleInput = 'rgb(255, 255, 255)';
        TextInput.prototype.strokeStyle = 'rgb(255, 255, 255)';
        TextInput.prototype.padding = 8;

        // Hidden DOM input
        TextInput.prototype.input = null;
        TextInput.prototype.cursor = null;
        TextInput.prototype.focus = false;
        TextInput.prototype.type = 'text';

        function TextInput(x, y, width, height, text, font, fillStyle, textAlign, strokeStyle, padding, fillStyleInput, type) {
            if (height) {
                this.height = height;
            }
            if (!font) {
                font = this.font;
            }
            if (!fillStyle) {
                fillStyle = this.fillStyle;
            }
            if (strokeStyle) {
                this.strokeStyle = strokeStyle;
            }
            if (padding) {
                this.padding = padding;
            }
            if (fillStyleInput) {
                this.fillStyleInput = fillStyleInput;
            }
            if (type) {
                this.type = type;
            }

            TextInput.__super__.constructor.call(this, x, y, width, text, font, fillStyle, textAlign);

            // Create the hidden input
            this.input = document.createElement('input');
            this.input.type = this.type;
            this.input.style.opacity = 1;
            this.input.style.position = 'absolute';
            this.input.style.top = '-10000px';
            this.input.style['z-index'] = -1;
            document.body.appendChild(this.input);

            // Create an event to pull text from hidden input
            var me = this;
            this.input.addEventListener('keyup', function(event) {
                me.text = me.input.value;
            });
        }

        TextInput.prototype.render = function(ctx, dt) {
            // Get the height of the font
            var fontSize = parseInt(this.font.substr(0, this.font.indexOf('px')));

            // Draw the rectangle
            ctx.fillStyle = this.fillStyleInput;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.strokeStyle = this.strokeStyle;
            ctx.strokeRect(this.x, this.y, this.width, this.height);

            // Draw the text
            if (this.font !== null) {
                ctx.font = this.font;
            }
            ctx.textAlign = this.textAlign;
            ctx.fillStyle = this.fillStyle;
            ctx.fillText(this.text, this.x + this.padding, this.y + fontSize + this.padding, this.width - this.padding * 2);

            // Create the cursor
            if (this.focus) {
                ctx.fillRect(this.x + 4, this.y + 2, 2, this.height - 4); 
            }
        };

        // Input click event, handle focus
        TextInput.prototype.click = function(event, scene) {
            // If the click was in the element
            if (Scene.isInside(scene.getEventCoords(event), this) && this.display) {
                // Set the focus on the hidden input
                this.input.focus();
                this.focus = true;
            }
            // Otherwise, remove the visual focus element
            else {
                this.focus = false;
            }
        };

        return TextInput;

    })();
})();

},{"../scene":17,"./text":11}],13:[function(require,module,exports){
/*
    Entity: TextMultiline
    Creates a text object
*/
(function () {
    'use strict';

    var Text = require('./text');

    module.exports = (function() {
        Text.extend(TextMultiline);

        TextMultiline.prototype.charsPerLine = 80;
        TextMultiline.prototype.lineHeight = 30;

        // The text split into lines
        TextMultiline.prototype.textArray = [];

        function TextMultiline(x, y, width, text, font, fillStyle, charsPerLine, lineHeight) {
            // Reset textArray for a deep copy
            this.textArray = [];

            TextMultiline.__super__.constructor.call(this, x, y, width, text, font, fillStyle);

            if (typeof charsPerLine !== 'undefined') {
                this.charsPerLine = charsPerLine;
            }
            if (typeof lineHeight !== 'undefined') {
                this.lineHeight = lineHeight;
            }

            // Create the text array
            var textWords = this.text.split(' ');
            var line = 0;
            while (textWords.length) {
                this.textArray[line] = textWords.shift();
                while (this.textArray[line] && (typeof textWords[0] !== 'undefined') && (this.textArray[line] + textWords[0]).length < this.charsPerLine) {
                    this.textArray[line] += ' ' + textWords.shift();
                }
                line++;
            }
        }

        TextMultiline.prototype.render = function(ctx, dt) {
            if (this.font !== null) {
                ctx.font = this.font;
            }
            ctx.fillStyle = this.fillStyle;

            for (var i = 0; i < this.textArray.length; i++) {
                ctx.fillText(this.textArray[i], this.x, this.y + i * this.lineHeight, this.width);
            }
        };

        return TextMultiline;

    })();
})();

},{"./text":11}],14:[function(require,module,exports){
(function () {
    'use strict';

    var Extendable = require('./extendable');

    module.exports = (function() {
        // Inherit from the Extendable class
        Extendable.extend(Entity);

        // Canvas Rendering
        Entity.prototype.display = true;
        Entity.prototype.x = 0;
        Entity.prototype.y = 0;
        Entity.prototype.width = 0;
        Entity.prototype.height = 0;
        Entity.prototype.color = 'rgb(0, 0, 0)';

        // Components
        Entity.prototype.components = {};

        function Entity(x, y, width, height, color) {
            // Set passed in args
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            if (color !== null) {
                this.color = color;
            }

            // Reset objects (for a deep copy)
            this.components = {};
        }

        // Draw the entity in the given context at the given coordinates
        Entity.prototype.render = function(ctx, dt) {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
        };

        // Add a component
        Entity.prototype.componentAdd = function(component) {
            this.components[component.name] = component;
        };

        // Remove a component
        Entity.prototype.componentRemove = function(Component) {
            delete this.components[Component.title];
        };

        return Entity;

    })();
})();

},{"./extendable":15}],15:[function(require,module,exports){
(function () {
    'use strict';

    module.exports = (function() {

        function Extendable() {
        }

        // Extend the given child as a subclass of the parent class
        Extendable.extend = function(child) {
            for (var key in this) {
                if (!child.prototype.hasOwnProperty(key)) {
                    child[key] = this[key];
                }
            }

            function Ctor() {
                this.constructor = child;
            }
            Ctor.prototype = this.prototype;
            child.prototype = new Ctor();

            child.__super__ = this.prototype;
        };

        return Extendable;

    })();
})();

},{}],16:[function(require,module,exports){
(function() {
    'use strict';

    var Engine = require('./engine');
    var Entity = require('./entity');
    var Extendable = require('./extendable');
    var Component = require('./component');
    var Scene = require('./scene');
    var Loading = require('./scenes/loading');
    var Sprite = require('./entities/sprite');
    var Text = require('./entities/text');
    var TextMultiline = require('./entities/textMultiline');
    var TextInput = require('./entities/textInput');
    var Button = require('./entities/button');
    var Tween = require('./components/tween');
    var Draggable = require('./components/draggable');
    var DragCreate = require('./components/dragCreate');
    var KeyMove = require('./components/keyMove');
    var Bounded = require('./components/bounded');
    var Collision = require('./components/collision');

    // Create the global hoopty object
    window.hoopty = {
        Engine: Engine,
        Extendable: Extendable,
        entities: {
            Entity: Entity,
            Sprite: Sprite,
            Text: Text,
            TextMultiline: TextMultiline,
            TextInput: TextInput,
            Button: Button,
        },
        components: {
            Component: Component,
            Bounded: Bounded,
            Collision: Collision,
            Draggable: Draggable,
            DragCreate: DragCreate,
            KeyMove: KeyMove,
            Tween: Tween,
        },
        scenes: {
            Scene: Scene,
            Loading: Loading,
        }
    };
})();

},{"./component":1,"./components/bounded":2,"./components/collision":3,"./components/dragCreate":4,"./components/draggable":5,"./components/keyMove":6,"./components/tween":7,"./engine":8,"./entities/button":9,"./entities/sprite":10,"./entities/text":11,"./entities/textInput":12,"./entities/textMultiline":13,"./entity":14,"./extendable":15,"./scene":17,"./scenes/loading":18}],17:[function(require,module,exports){
(function () {
    'use strict';

    var Extendable = require('./extendable');

    module.exports = (function() {
        // Inherit from the Extendable class
        Extendable.extend(Scene);

        Scene.prototype.route = '/';

        Scene.prototype.entities = [];

        Scene.prototype.engine = null;

        // Used by the draggable component to limit dragging to 1 entity at a time
        Scene.prototype.dragging = false;

        function Scene(engine) {
            this.engine = engine;

            // Reset the entities object
            this.entities = [];
        }

        // Draw the entity in the given context at the given coordinates
        Scene.prototype.render = function(ctx, dt) {
            // Update the ctx
            this.ctx = ctx;

            // Render entities
            var me = this;
            this.entities.forEach(function(elt) {
                if (elt.display) {
                    me.eventFire({type: 'preRender', dt: dt});
                    elt.render(ctx, dt);
                }
            });
        };

        // Create an entity
        Scene.prototype.entityAdd = function(entity) {
            this.entities.push(entity);
            return this.entities[this.entities.length - 1];
        };

        // Remove an entity.  Returns true if found, false if not found
        Scene.prototype.entityRemove = function(entity) {
            for (var i in this.entities) {
                var entityCheck = this.entities[i];
                if (entityCheck === entity) {
                    this.entities.splice(i, 1);
                    return true;
                }
            }

            return false;
        };

        // Call the given event responder on all entity components listening
        Scene.prototype.eventFire = function(event) {
            // Fire on the scene
            if (event.type in this) {
                this[event.type](event);
            }

            // Loop through in reverse order, to fire on recent, top entities first
            for (var i = this.entities.length - 1; i >= 0; i--) {
                // Fire on all entities
                var entity = this.entities[i];
                if (event.type in entity) {
                    entity[event.type](event, this);
                }
                for (var j in entity.components) {
                    // Fire on all components on the given entity
                    var component = entity.components[j];
                    if (event.type in component) {
                        component[event.type](event, this);
                    }
                }
            }
        };

        // Gets the coordinates of an event on the canvas relative to the canvas
        Scene.prototype.getEventCoords = function(event) {
            // Only if we have ctx (have rendered)
            if ('ctx' in this) {
                var totalOffsetX = 0;
                var totalOffsetY = 0;
                var canvasX = 0;
                var canvasY = 0;
                var currentElement = this.ctx.canvas;

                // Get the direct event x/y
                var eventX = 0;
                var eventY = 0;
                if (event.type === 'touchstart' || event.type === 'touchmove' || event.type === 'touchend' || event.type === 'touchcancel') {
                    var eventOriginal = event.touches[0] || event.changedTouches[0];
                    eventX = eventOriginal.pageX;
                    eventY = eventOriginal.pageY;
                }
                else {
                    eventX = event.pageX;
                    eventY = event.pageY;
                }

                // Get the coords with respect to the canvas
                do {
                    totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
                    totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
                }
                while(currentElement = currentElement.offsetParent);

                canvasX = eventX - totalOffsetX;
                canvasY = eventY - totalOffsetY;

                // Scale the coords if the canvas is scaled
                var scale = this.ctx.canvas.width / this.ctx.canvas.style.width.substr(0, this.ctx.canvas.style.width.length - 2);
                canvasX *= scale;
                canvasY *= scale;

                return {x:canvasX, y:canvasY};
            }
            else {
                return {x: 0, y: 0};
            }
        };

        // Returns true if the coords are inside the object, false otherwise
        Scene.isInside = function(coords, entity) {
            if ((coords.x >= entity.x) && (coords.x <= entity.x + entity.width)) {
                if ((coords.y >= entity.y) && (coords.y <= entity.y + entity.height)) {
                    return true;
                }
            }
            return false;
        };

        // Returns true if the two entities overlap
        Scene.isOverlap = function(entity1, entity2) {
            var rect1X1 = entity1.x;
            var rect1X2 = entity1.x + entity1.width;
            var rect1Y1 = entity1.y;
            var rect1Y2 = entity1.y + entity1.height;
            var rect2X1 = entity2.x;
            var rect2X2 = entity2.x + entity2.width;
            var rect2Y1 = entity2.y;
            var rect2Y2 = entity2.y + entity2.height;

            if (rect1X1 < rect2X2 && rect1X2 > rect2X1 && rect1Y1 < rect2Y2 && rect1Y2 > rect2Y1) {
                return true;
            }
            return false;
        };

        // Returns an object with x and y set to the midpoint of the two entities
        Scene.getMidpoint = function(entity1, entity2) {
            var coords = {x: 0, y: 0};

            coords.x = Math.round((entity1.x + entity2.x) / 2);
            coords.y = Math.round((entity1.y + entity2.y) / 2);

            return coords;
        };

        // Reset the current scene
        Scene.prototype.reset = function() {
            this.engine.scenes[this.name] = new Scene(this.engine);
            this.engine.changeScenes(this.name);
        };

        // Destroy this scene by removing its refrence in engine
        Scene.prototype.destroy = function() {
            this.engine.sceneDestroy(this.name);
        };

        return Scene;

    })();
})();

},{"./extendable":15}],18:[function(require,module,exports){
/*
    Scene: Loading
    The initial loading screen
*/
(function () {
    'use strict';

    var Scene = require('../scene');
    var Text = require('../entities/text');

    module.exports = (function() {
        Scene.extend(Loading);

        Loading.prototype.name = 'Loading';

        // The scene to change to when loading is done
        Loading.prototype.sceneNameChangeTo = 'Start';

        Loading.prototype.urlCount = 0;
        Loading.prototype.urlsDone = 0;

        function Loading(engine, urls, sceneNameChangeTo) {
            if (sceneNameChangeTo) {
                this.sceneNameChangeTo = sceneNameChangeTo;
            }

            Loading.__super__.constructor.call(this, engine);

            // Get the url count
            if (!urls) {
                urls = [];
            }
            this.urlCount = urls.length;

            // Create the title
            this.entityAdd(new Text(this.engine.ctx.canvas.width / 4, 260, 0, 'Loading...', '50px \'Press Start 2P\'', 'rgb(0, 0, 0)'));

            // Load each url
            var me = this;
            urls.forEach(function(url) {
                var image = new Image();
                image.addEventListener('load', function() {
                    me.urlsDone++;
                }, false);
                image.src = url;
            });
        }

        Loading.prototype.render = function(ctx, dt) {
            // Go to next scene if all loaded
            if (this.urlsDone >= this.urlCount) {
                this.engine.changeScenes(this.sceneNameChangeTo);
            }

            // Set the background
            ctx.fillStyle = 'rgb(255, 255, 255)';
            ctx.fillRect (0, 0, ctx.canvas.width, ctx.canvas.height);

            Loading.__super__.render.call(this, ctx, dt);
        };

        return Loading;

    })();
})();

},{"../entities/text":11,"../scene":17}]},{},[16])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdXN0aW4vRG9jdW1lbnRzL1Byb2plY3RzL2hvb3B0eS9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvanVzdGluL0RvY3VtZW50cy9Qcm9qZWN0cy9ob29wdHkvYXBwL3NjcmlwdHMvY29tcG9uZW50LmpzIiwiL1VzZXJzL2p1c3Rpbi9Eb2N1bWVudHMvUHJvamVjdHMvaG9vcHR5L2FwcC9zY3JpcHRzL2NvbXBvbmVudHMvYm91bmRlZC5qcyIsIi9Vc2Vycy9qdXN0aW4vRG9jdW1lbnRzL1Byb2plY3RzL2hvb3B0eS9hcHAvc2NyaXB0cy9jb21wb25lbnRzL2NvbGxpc2lvbi5qcyIsIi9Vc2Vycy9qdXN0aW4vRG9jdW1lbnRzL1Byb2plY3RzL2hvb3B0eS9hcHAvc2NyaXB0cy9jb21wb25lbnRzL2RyYWdDcmVhdGUuanMiLCIvVXNlcnMvanVzdGluL0RvY3VtZW50cy9Qcm9qZWN0cy9ob29wdHkvYXBwL3NjcmlwdHMvY29tcG9uZW50cy9kcmFnZ2FibGUuanMiLCIvVXNlcnMvanVzdGluL0RvY3VtZW50cy9Qcm9qZWN0cy9ob29wdHkvYXBwL3NjcmlwdHMvY29tcG9uZW50cy9rZXlNb3ZlLmpzIiwiL1VzZXJzL2p1c3Rpbi9Eb2N1bWVudHMvUHJvamVjdHMvaG9vcHR5L2FwcC9zY3JpcHRzL2NvbXBvbmVudHMvdHdlZW4uanMiLCIvVXNlcnMvanVzdGluL0RvY3VtZW50cy9Qcm9qZWN0cy9ob29wdHkvYXBwL3NjcmlwdHMvZW5naW5lLmpzIiwiL1VzZXJzL2p1c3Rpbi9Eb2N1bWVudHMvUHJvamVjdHMvaG9vcHR5L2FwcC9zY3JpcHRzL2VudGl0aWVzL2J1dHRvbi5qcyIsIi9Vc2Vycy9qdXN0aW4vRG9jdW1lbnRzL1Byb2plY3RzL2hvb3B0eS9hcHAvc2NyaXB0cy9lbnRpdGllcy9zcHJpdGUuanMiLCIvVXNlcnMvanVzdGluL0RvY3VtZW50cy9Qcm9qZWN0cy9ob29wdHkvYXBwL3NjcmlwdHMvZW50aXRpZXMvdGV4dC5qcyIsIi9Vc2Vycy9qdXN0aW4vRG9jdW1lbnRzL1Byb2plY3RzL2hvb3B0eS9hcHAvc2NyaXB0cy9lbnRpdGllcy90ZXh0SW5wdXQuanMiLCIvVXNlcnMvanVzdGluL0RvY3VtZW50cy9Qcm9qZWN0cy9ob29wdHkvYXBwL3NjcmlwdHMvZW50aXRpZXMvdGV4dE11bHRpbGluZS5qcyIsIi9Vc2Vycy9qdXN0aW4vRG9jdW1lbnRzL1Byb2plY3RzL2hvb3B0eS9hcHAvc2NyaXB0cy9lbnRpdHkuanMiLCIvVXNlcnMvanVzdGluL0RvY3VtZW50cy9Qcm9qZWN0cy9ob29wdHkvYXBwL3NjcmlwdHMvZXh0ZW5kYWJsZS5qcyIsIi9Vc2Vycy9qdXN0aW4vRG9jdW1lbnRzL1Byb2plY3RzL2hvb3B0eS9hcHAvc2NyaXB0cy9mYWtlXzFiYjQxOTVhLmpzIiwiL1VzZXJzL2p1c3Rpbi9Eb2N1bWVudHMvUHJvamVjdHMvaG9vcHR5L2FwcC9zY3JpcHRzL3NjZW5lLmpzIiwiL1VzZXJzL2p1c3Rpbi9Eb2N1bWVudHMvUHJvamVjdHMvaG9vcHR5L2FwcC9zY3JpcHRzL3NjZW5lcy9sb2FkaW5nLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRXh0ZW5kYWJsZSA9IHJlcXVpcmUoJy4vZXh0ZW5kYWJsZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEluaGVyaXQgZnJvbSB0aGUgRXh0ZW5kYWJsZSBjbGFzc1xuICAgICAgICBFeHRlbmRhYmxlLmV4dGVuZChDb21wb25lbnQpO1xuXG4gICAgICAgIC8vIFRoZSBlbnRpdHkgdGhhdCBpcyBhc3NpZ25lZCB0aGlzIGNvbXBvbmVudFxuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmVudGl0eSA9IHt9O1xuXG4gICAgICAgIC8vIFRoZSBuYW1lIHRvIHJlZmVyIHRvIHRoaXMgY29tcG9uZW50XG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUubmFtZSA9ICdDb21wb25lbnQnO1xuICAgICAgICBDb21wb25lbnQudGl0bGUgPSAnQ29tcG9uZW50JztcblxuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnQoZW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmVudGl0eSA9IGVudGl0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZ1bmN0aW9ucyBjYWxsZWQgd2hlbiB0aGUgZW50aXR5IHJlY2VpdmVzIHRoZSBnaXZlbiBldmVudFxuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnJlc3BvbmRFdmVudHMgPSB7fTtcblxuICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xuXG4gICAgfSkoKTtcbn0pKCk7XG4iLCIvKlxuICAgIENvbXBvbmVudDogQm91bmRlZFxuICAgIFByZXZlbnRzIG1vdmluZyBvdXRzaWRlIHRoZSBjYW52YXNcbiovXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb21wb25lbnQnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJbmhlcml0IGZyb20gdGhlIENvbXBvbmVudCBjbGFzc1xuICAgICAgICBDb21wb25lbnQuZXh0ZW5kKEJvdW5kZWQpO1xuXG4gICAgICAgIC8vIFRoZSBuYW1lIHRvIHJlZmVyIHRvIHRoaXMgY29tcG9uZW50XG4gICAgICAgIEJvdW5kZWQucHJvdG90eXBlLm5hbWUgPSAnQm91bmRlZCc7XG4gICAgICAgIEJvdW5kZWQudGl0bGUgPSAnQm91bmRlZCc7XG5cbiAgICAgICAgLy8gVGhlIGxvY2F0aW9uIHRvIGJlIGJvdW5kZWQgd2l0aGluXG4gICAgICAgIEJvdW5kZWQucHJvdG90eXBlLnggPSBudWxsO1xuICAgICAgICBCb3VuZGVkLnByb3RvdHlwZS55ID0gbnVsbDtcbiAgICAgICAgQm91bmRlZC5wcm90b3R5cGUud2lkdGggPSBudWxsO1xuICAgICAgICBCb3VuZGVkLnByb3RvdHlwZS5oZWlnaHQgPSBudWxsO1xuXG4gICAgICAgIGZ1bmN0aW9uIEJvdW5kZWQoZW50aXR5LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJvdW5kZWQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZW50aXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIEJvdW5kZWQucHJvdG90eXBlLnByZVJlbmRlciA9IGZ1bmN0aW9uKGV2ZW50LCBzY2VuZSkge1xuICAgICAgICAgICAgLy8gSWYgbm8gYXJncyBwYXNzZWQsIGJvdW5kIGluc2lkZSB3aG9sZSBjYW52YXNcbiAgICAgICAgICAgIGlmICh0aGlzLnggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMueSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBzY2VuZS5jdHguY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzY2VuZS5jdHguY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm9ydGggRWRnZVxuICAgICAgICAgICAgaWYgKHRoaXMuZW50aXR5LnkgPCB0aGlzLnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGl0eS55ID0gdGhpcy55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFYXN0IEVkZ2VcbiAgICAgICAgICAgIGlmICh0aGlzLmVudGl0eS54ICsgdGhpcy5lbnRpdHkud2lkdGggPiB0aGlzLnggKyB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRpdHkueCA9IHRoaXMueCArIHRoaXMud2lkdGggLSB0aGlzLmVudGl0eS53aWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU291dGggRWRnZVxuICAgICAgICAgICAgaWYgKHRoaXMuZW50aXR5LnkgKyB0aGlzLmVudGl0eS5oZWlnaHQgPiB0aGlzLnkgKyB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5LnkgPSB0aGlzLmhlaWdodCAtIHRoaXMueSAtIHRoaXMuZW50aXR5LmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2VzdCBFZGdlXG4gICAgICAgICAgICBpZiAodGhpcy5lbnRpdHkueCA8IHRoaXMueCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5LnggPSB0aGlzLng7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEJvdW5kZWQ7XG5cbiAgICB9KSgpO1xufSkoKTtcbiIsIi8qXG4gICAgQ29tcG9uZW50OiBDb2xsaXNpb25cbiAgICBDYWxscyBhIGNhbGxiYWNrIHdoZW4gY29sbGlkaW5nIHdpdGggYW5vdGhlciBlbnRpdHlcbiovXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTY2VuZSA9IHJlcXVpcmUoJy4uL3NjZW5lJyk7XG4gICAgdmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEluaGVyaXQgZnJvbSB0aGUgQ29tcG9uZW50IGNsYXNzXG4gICAgICAgIENvbXBvbmVudC5leHRlbmQoQ29sbGlzaW9uKTtcblxuICAgICAgICAvLyBUaGUgbmFtZSB0byByZWZlciB0byB0aGlzIGNvbXBvbmVudFxuICAgICAgICBDb2xsaXNpb24ucHJvdG90eXBlLm5hbWUgPSAnQ29sbGlzaW9uJztcbiAgICAgICAgQ29sbGlzaW9uLnRpdGxlID0gJ0NvbGxpc2lvbic7XG5cbiAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgYSBjb2xsaXNpb24gd2FzIGRldGVjdGVkXG4gICAgICAgIENvbGxpc2lvbi5wcm90b3R5cGUuY2FsbGJhY2sgPSBudWxsO1xuXG4gICAgICAgIC8vIFRoZSBldmVudCB0byBsaXN0ZW4gdG8gYW5kIGNoZWNrIGZvciBhIGNvbGxpc2lvblxuICAgICAgICBDb2xsaXNpb24ucHJvdG90eXBlLmV2ZW50TmFtZSA9ICdwcmVSZW5kZXInO1xuXG4gICAgICAgIC8vIFRoZSBjb21wb25lbnQgb24gb3RoZXIgZW50aXRpZXMgdGhhdCBjYW4gYmUgY29sbGlkZWQgd2l0aFxuICAgICAgICAvLyBJZiBub25lIGdpdmVuLCBhbGwgY2FuIGJlIGNvbGxpZGVkIHdpdGhcbiAgICAgICAgQ29sbGlzaW9uLnByb3RvdHlwZS5jb21wb25lbnRDb2xsaWRhYmxlID0gbnVsbDtcblxuICAgICAgICBmdW5jdGlvbiBDb2xsaXNpb24oZW50aXR5LCBjb21wb25lbnRDb2xsaWRhYmxlLCBjYWxsYmFjaywgZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmVudGl0eSA9IGVudGl0eTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Q29sbGlkYWJsZSA9IGNvbXBvbmVudENvbGxpZGFibGU7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIENvbGxpc2lvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbnRpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgQ29sbGlzaW9uLnByb3RvdHlwZS5wcmVSZW5kZXIgPSBmdW5jdGlvbihldmVudCwgc2NlbmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50TmFtZSA9PT0gZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2soZXZlbnQsIHNjZW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBDb2xsaXNpb24ucHJvdG90eXBlLm1vdXNldXAgPSBmdW5jdGlvbihldmVudCwgc2NlbmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50TmFtZSA9PT0gZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2soZXZlbnQsIHNjZW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBDb2xsaXNpb24ucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uKGV2ZW50LCBzY2VuZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnROYW1lID09PSBldmVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVjayhldmVudCwgc2NlbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIENvbGxpc2lvbi5wcm90b3R5cGUubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZlbnQsIHNjZW5lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudE5hbWUgPT09IGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrKGV2ZW50LCBzY2VuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgY29sbGlzaW9uIGFuZCBhY3RcbiAgICAgICAgQ29sbGlzaW9uLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGV2ZW50LCBzY2VuZSkge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgY29sbGlkZSB3aXRoIGEgaGlkZGVuIGVudGl0eVxuICAgICAgICAgICAgaWYgKHRoaXMuZW50aXR5LmRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIGVudGl0aWVzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBzY2VuZS5lbnRpdGllcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50aXR5ID0gc2NlbmUuZW50aXRpZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gd2UgY2FyZSBpZiB0aGVzZSBlbnRpdGllcyBvdmVybGFwP1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZW50aXR5ICE9PSBlbnRpdHkpICYmIGVudGl0eS5kaXNwbGF5ICYmICgodGhpcy5jb21wb25lbnRDb2xsaWRhYmxlID09PSBudWxsKSB8fCAodGhpcy5jb21wb25lbnRDb2xsaWRhYmxlIGluIGVudGl0eS5jb21wb25lbnRzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbnRpdGllcyBvdmVybGFwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoU2NlbmUuaXNPdmVybGFwKHRoaXMuZW50aXR5LCBlbnRpdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2shXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhldmVudCwgc2NlbmUsIGVudGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbjtcblxuICAgIH0pKCk7XG59KSgpO1xuIiwiLypcbiAgICBDb21wb25lbnQ6IERyYWdDcmVhdGVcbiAgICBPbiBkcmFnLCBjcmVhdGVzIGEgbmV3IGRyYWdnYWJsZSBlbnRpdHkgYW5kIGRyYWdzIGl0XG4gICAgQWxhIGdldHRpbmcgc29tZXRoaW5nIGZyb20gYSB0b29sYmFyXG4qL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgU2NlbmUgPSByZXF1aXJlKCcuLi9zY2VuZScpO1xuICAgIHZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb21wb25lbnQnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJbmhlcml0IGZyb20gdGhlIENvbXBvbmVudCBjbGFzc1xuICAgICAgICBDb21wb25lbnQuZXh0ZW5kKERyYWdDcmVhdGUpO1xuXG4gICAgICAgIC8vIFRoZSBuYW1lIHRvIHJlZmVyIHRvIHRoaXMgY29tcG9uZW50XG4gICAgICAgIERyYWdDcmVhdGUucHJvdG90eXBlLm5hbWUgPSAnRHJhZ0NyZWF0ZSc7XG4gICAgICAgIERyYWdDcmVhdGUudGl0bGUgPSAnRHJhZ0NyZWF0ZSc7XG5cbiAgICAgICAgLy8gQW4gZW50aXR5IHRvIGJlIGNyZWF0ZWQgb24gZHJhZywgYm91bmQgdG8gaXRzIGFyZ3VtZW50c1xuICAgICAgICAvLyBTbyBjb3VsZCBiZSBwYXNzZWQgYXMgdGhpcyBmb3IgZXhhbXBsZTogRW50aXR5LmJpbmQodGhpcywgMCwgMClcbiAgICAgICAgRHJhZ0NyZWF0ZS5wcm90b3R5cGUuRW50aXR5RHJhZ0JpbmQgPSBudWxsO1xuXG4gICAgICAgIC8vIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBhbiBlbnRpdHkgaXMgY3JlYXRlZFxuICAgICAgICAvLyBSZWNlaXZlcyBwYXJhbWV0ZXJzIGV2ZW50LCBzY2VuZSwgYW5kIGVudGl0eVxuICAgICAgICBEcmFnQ3JlYXRlLnByb3RvdHlwZS5jYWxsYmFjayA9IG51bGw7XG5cbiAgICAgICAgZnVuY3Rpb24gRHJhZ0NyZWF0ZShlbnRpdHksIEVudGl0eURyYWdCaW5kLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5FbnRpdHlEcmFnQmluZCA9IEVudGl0eURyYWdCaW5kO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIERyYWdDcmVhdGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZW50aXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIERyYWdDcmVhdGUucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbihldmVudCwgc2NlbmUpIHtcbiAgICAgICAgICAgIC8vIENhbGwgZXZlbnQucHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0b3VjaGNhbmNlbCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGlmIChTY2VuZS5pc0luc2lkZShzY2VuZS5nZXRFdmVudENvb3JkcyhldmVudCksIHRoaXMuZW50aXR5KSAmJiB0aGlzLmVudGl0eS5kaXNwbGF5ICYmICFzY2VuZS5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZyhldmVudCwgc2NlbmUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIERyYWdDcmVhdGUucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uKGV2ZW50LCBzY2VuZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnKGV2ZW50LCBzY2VuZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgRHJhZ0NyZWF0ZS5wcm90b3R5cGUuZHJhZyA9IGZ1bmN0aW9uKGV2ZW50LCBzY2VuZSkge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgZHJhZ2NyZWF0ZSBoaWRkZW4gZW50aXRpZXNcbiAgICAgICAgICAgIGlmICh0aGlzLmVudGl0eS5kaXNwbGF5ICYmICFzY2VuZS5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBzY2VuZS5nZXRFdmVudENvb3JkcyhldmVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGVudGl0eSB3YXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIGlmIChTY2VuZS5pc0luc2lkZShjb29yZHMsIHRoaXMuZW50aXR5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBlbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gc2NlbmUuZW50aXR5QWRkKG5ldyB0aGlzLkVudGl0eURyYWdCaW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZy54ID0gdGhpcy5lbnRpdHkueDtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcueSA9IHRoaXMuZW50aXR5Lnk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nLmNvbXBvbmVudHMuRHJhZ2dhYmxlLmRyYWdnaW5nWCA9IGNvb3Jkcy54IC0gdGhpcy5lbnRpdHkueDtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcuY29tcG9uZW50cy5EcmFnZ2FibGUuZHJhZ2dpbmdZID0gY29vcmRzLnkgLSB0aGlzLmVudGl0eS55O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIGlmIGdpdmVuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGV2ZW50LCBzY2VuZSwgdGhpcy5lbnRpdHksIGRyYWdnaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRHJhZ0NyZWF0ZTtcblxuICAgIH0pKCk7XG59KSgpO1xuIiwiLypcbiAgICBDb21wb25lbnQ6IERyYWdnYWJsZVxuICAgIE1ha2VzIHRoZSBlbnRpdHkgZHJhZ2dhYmxlIHdpdGggdGhlIG1vdXNlXG4qL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gXG4gICAgdmFyIFNjZW5lID0gcmVxdWlyZSgnLi4vc2NlbmUnKTtcbiAgICB2YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSW5oZXJpdCBmcm9tIHRoZSBDb21wb25lbnQgY2xhc3NcbiAgICAgICAgQ29tcG9uZW50LmV4dGVuZChEcmFnZ2FibGUpO1xuXG4gICAgICAgIC8vIFRoZSBuYW1lIHRvIHJlZmVyIHRvIHRoaXMgY29tcG9uZW50XG4gICAgICAgIERyYWdnYWJsZS5wcm90b3R5cGUubmFtZSA9ICdEcmFnZ2FibGUnO1xuICAgICAgICBEcmFnZ2FibGUudGl0bGUgPSAnRHJhZ2dhYmxlJztcblxuICAgICAgICBEcmFnZ2FibGUucHJvdG90eXBlLmRyYWdnaW5nWCA9IG51bGw7XG4gICAgICAgIERyYWdnYWJsZS5wcm90b3R5cGUuZHJhZ2dpbmdZID0gbnVsbDtcblxuICAgICAgICBmdW5jdGlvbiBEcmFnZ2FibGUoZW50aXR5KSB7XG4gICAgICAgICAgICBEcmFnZ2FibGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZW50aXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIERyYWdnYWJsZS5wcm90b3R5cGUubW91c2Vkb3duID0gZnVuY3Rpb24oZXZlbnQsIHNjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydChldmVudCwgc2NlbmUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIERyYWdnYWJsZS5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uKGV2ZW50LCBzY2VuZSkge1xuICAgICAgICAgICAgLy8gQ2FsbCBldmVudC5wcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRvdWNoY2FuY2VsIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKFNjZW5lLmlzSW5zaWRlKHNjZW5lLmdldEV2ZW50Q29vcmRzKGV2ZW50KSwgdGhpcy5lbnRpdHkpICYmIHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnQoZXZlbnQsIHNjZW5lKTtcbiAgICAgICAgfTtcblxuICAgICAgICBEcmFnZ2FibGUucHJvdG90eXBlLm1vdXNlbW92ZSA9IGZ1bmN0aW9uKGV2ZW50LCBzY2VuZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnTW92ZShldmVudCwgc2NlbmUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIERyYWdnYWJsZS5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24oZXZlbnQsIHNjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdNb3ZlKGV2ZW50LCBzY2VuZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgRHJhZ2dhYmxlLnByb3RvdHlwZS5tb3VzZXVwID0gZnVuY3Rpb24oZXZlbnQsIHNjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbmQoZXZlbnQsIHNjZW5lKTtcbiAgICAgICAgfTtcblxuICAgICAgICBEcmFnZ2FibGUucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24oZXZlbnQsIHNjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbmQoZXZlbnQsIHNjZW5lKTtcbiAgICAgICAgfTtcblxuICAgICAgICBEcmFnZ2FibGUucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uKGV2ZW50LCBzY2VuZSkge1xuICAgICAgICAgICAgaWYgKHNjZW5lLmRyYWdnaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBzY2VuZS5nZXRFdmVudENvb3JkcyhldmVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGVudGl0eSB3YXMgY2xpY2tlZCwgYW5kIHN0YXJ0IGRyYWdnaW5nIGl0IGlmIHNvXG4gICAgICAgICAgICAgICAgaWYgKFNjZW5lLmlzSW5zaWRlKGNvb3JkcywgdGhpcy5lbnRpdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1ggPSBjb29yZHMueCAtIHRoaXMuZW50aXR5Lng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdZID0gY29vcmRzLnkgLSB0aGlzLmVudGl0eS55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBEcmFnZ2FibGUucHJvdG90eXBlLmRyYWdNb3ZlID0gZnVuY3Rpb24oZXZlbnQsIHNjZW5lKSB7XG4gICAgICAgICAgICAvLyBEcmFnIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHNjZW5lLmdldEV2ZW50Q29vcmRzKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGl0eS54ID0gY29vcmRzLnggLSB0aGlzLmRyYWdnaW5nWDtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGl0eS55ID0gY29vcmRzLnkgLSB0aGlzLmRyYWdnaW5nWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBEcmFnZ2FibGUucHJvdG90eXBlLmRyYWdFbmQgPSBmdW5jdGlvbihldmVudCwgc2NlbmUpIHtcbiAgICAgICAgICAgIC8vIFJlbGVhc2UgYSBkcmFnIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gc2NlbmUuZ2V0RXZlbnRDb29yZHMoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5LnggPSBjb29yZHMueCAtIHRoaXMuZHJhZ2dpbmdYO1xuICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5LnkgPSBjb29yZHMueSAtIHRoaXMuZHJhZ2dpbmdZO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdYID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nWSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgRHJhZ2dhYmxlLnByb3RvdHlwZS5pc0RyYWdnaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuZHJhZ2dpbmdYICE9PSBudWxsKSAmJiAodGhpcy5kcmFnZ2luZ1kgIT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIERyYWdnYWJsZTtcblxuICAgIH0pKCk7XG59KSgpO1xuIiwiLypcbiAgICBDb21wb25lbnQ6IGtleU1vdmVcbiAgICBNYWtlcyB0aGUgZW50aXR5IG1vdmFibGUgd2l0aCB0aGUga2V5Ym9hcmQsIGFsYSB0aGUgcGxheWVyIGNoYXJhY3RlclxuKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFNjZW5lID0gcmVxdWlyZSgnLi4vc2NlbmUnKTtcbiAgICB2YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSW5oZXJpdCBmcm9tIHRoZSBDb21wb25lbnQgY2xhc3NcbiAgICAgICAgQ29tcG9uZW50LmV4dGVuZChPYmopO1xuXG4gICAgICAgIC8vIFRoZSBuYW1lIHRvIHJlZmVyIHRvIHRoaXMgY29tcG9uZW50XG4gICAgICAgIE9iai5wcm90b3R5cGUubmFtZSA9ICdLZXlNb3ZlJztcbiAgICAgICAgT2JqLnRpdGxlID0gJ0tleU1vdmUnO1xuXG4gICAgICAgIC8vIERlZmF1bHRcbiAgICAgICAgT2JqLnByb3RvdHlwZS5zcGVlZCA9IDEwMDsgLy8gcGl4ZWxzIC8gc2Vjb25kXG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBrZXlzIGFyZSBwcmVzc2VkXG4gICAgICAgIE9iai5wcm90b3R5cGUudXAgPSBmYWxzZTtcbiAgICAgICAgT2JqLnByb3RvdHlwZS5kb3duID0gZmFsc2U7XG4gICAgICAgIE9iai5wcm90b3R5cGUubGVmdCA9IGZhbHNlO1xuICAgICAgICBPYmoucHJvdG90eXBlLnJpZ2h0ID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gT2JqKGVudGl0eSwgc3BlZWQpIHtcbiAgICAgICAgICAgIE9iai5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbnRpdHkpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWVkICE9PSAndW5kZWZpbmVkJyAmJiBzcGVlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iai5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uKGV2ZW50LCBzY2VuZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRLZXkoZXZlbnQud2hpY2gsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIE9iai5wcm90b3R5cGUua2V5dXAgPSBmdW5jdGlvbihldmVudCwgc2NlbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0S2V5KGV2ZW50LndoaWNoLCBmYWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqLnByb3RvdHlwZS5wcmVSZW5kZXIgPSBmdW5jdGlvbihldmVudCwgc2NlbmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRpdHkueSAtPSB0aGlzLnNwZWVkICogZXZlbnQuZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kb3duKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRpdHkueSArPSB0aGlzLnNwZWVkICogZXZlbnQuZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRpdHkueCAtPSB0aGlzLnNwZWVkICogZXZlbnQuZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5LnggKz0gdGhpcy5zcGVlZCAqIGV2ZW50LmR0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIE9iai5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24od2hpY2gsIHByZXNzZWQpIHtcbiAgICAgICAgICAgIC8vIFVwICh1cCBhcnJvdywgdylcbiAgICAgICAgICAgIGlmICh3aGljaCA9PT0gMzggfHwgd2hpY2ggPT09IDg3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cCA9IHByZXNzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb3duIChkb3duIGFycm93LCBzKVxuICAgICAgICAgICAgaWYgKHdoaWNoID09PSA0MCB8fCB3aGljaCA9PT0gODMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvd24gPSBwcmVzc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGVmdCAobGVmdCBhcnJvdywgYSlcbiAgICAgICAgICAgIGlmICh3aGljaCA9PT0gMzcgfHwgd2hpY2ggPT09IDY1KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gcHJlc3NlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJpZ2h0IChyaWdodCBhcnJvdywgZClcbiAgICAgICAgICAgIGlmICh3aGljaCA9PT0gMzkgfHwgd2hpY2ggPT09IDY4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCA9IHByZXNzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIE9iajtcblxuICAgIH0pKCk7XG59KSgpO1xuIiwiLypcbiAgICBDb21wb25lbnQ6IFR3ZWVuXG4gICAgQWxsb3dzIG1vdmluZyBhbmltYXRpb25zXG4qL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSW5oZXJpdCBmcm9tIHRoZSBDb21wb25lbnQgY2xhc3NcbiAgICAgICAgQ29tcG9uZW50LmV4dGVuZChUd2Vlbik7XG5cbiAgICAgICAgLy8gVGhlIG5hbWUgdG8gcmVmZXIgdG8gdGhpcyBjb21wb25lbnRcbiAgICAgICAgVHdlZW4ucHJvdG90eXBlLm5hbWUgPSAnVHdlZW4nO1xuICAgICAgICBUd2Vlbi50aXRsZSA9ICdUd2Vlbic7XG5cbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICBUd2Vlbi5wcm90b3R5cGUueCA9IG51bGw7XG4gICAgICAgIFR3ZWVuLnByb3RvdHlwZS55ID0gbnVsbDtcbiAgICAgICAgVHdlZW4ucHJvdG90eXBlLmNhbGxiYWNrID0gbnVsbDtcblxuICAgICAgICBUd2Vlbi5wcm90b3R5cGUueDAgPSBudWxsO1xuICAgICAgICBUd2Vlbi5wcm90b3R5cGUueTAgPSBudWxsO1xuXG4gICAgICAgIFR3ZWVuLnByb3RvdHlwZS50aW1lID0gMDtcbiAgICAgICAgVHdlZW4ucHJvdG90eXBlLmR1cmF0aW9uID0gbnVsbDtcblxuICAgICAgICBUd2Vlbi5wcm90b3R5cGUubXggPSBudWxsO1xuICAgICAgICBUd2Vlbi5wcm90b3R5cGUubXkgPSBudWxsO1xuXG4gICAgICAgIGZ1bmN0aW9uIFR3ZWVuKGVudGl0eSwgeCwgeSwgc3BlZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICB0aGlzLngwID0gZW50aXR5Lng7XG4gICAgICAgICAgICB0aGlzLnkwID0gZW50aXR5Lnk7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIHBvaW50c1xuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnBvdyhNYXRoLnBvdyh5IC0gZW50aXR5LnksIDIpICsgTWF0aC5wb3coeCAtIGVudGl0eS54LCAyKSwgMS8yKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0aW1lIHRvIHJlYWNoIHRoaXMgcG9pbnRcbiAgICAgICAgICAgIGlmIChzcGVlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBkIC8gc3BlZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGltZSBzbG9wZXMgaW4geCBhbmQgeSBkaXJlY2l0b25zXG4gICAgICAgICAgICB0aGlzLm14ID0gKHggLSBlbnRpdHkueCkgLyB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5teSA9ICh5IC0gZW50aXR5LnkpIC8gdGhpcy5kdXJhdGlvbjtcblxuICAgICAgICAgICAgVHdlZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZW50aXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFR3ZWVuLnByb3RvdHlwZS5wcmVSZW5kZXIgPSBmdW5jdGlvbihldmVudCwgc2NlbmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWUgIT09IG51bGwgJiYgdGhpcy50aW1lIDwgdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZSArPSBldmVudC5kdDtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lID49IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBlbnRpdHkgYXQgaXRzIGZpbmFsIHBsYWNlIGFuZCByZXNldCB0aGUgdGltZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5LnggPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5LnkgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGV2ZW50LCB0aGlzLmVudGl0eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIG1vdmUgaXQgbW92ZSBpdFxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVudGl0eS54ID0gdGhpcy54MCArIHRoaXMubXggKiB0aGlzLnRpbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5LnkgPSB0aGlzLnkwICsgdGhpcy5teSAqIHRoaXMudGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFR3ZWVuO1xuXG4gICAgfSkoKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTY2VuZSA9IHJlcXVpcmUoJy4vc2NlbmUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIERPTSBPYmplY3RzXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuY2FudmFzID0gbnVsbDtcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5jdHggPSBudWxsO1xuXG4gICAgICAgIC8vIFNjZW5lc1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNjZW5lcyA9IHt9O1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNjZW5lQWN0aXZlID0gbnVsbDtcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5jaGFuZ2VTY2VuZXNDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2NlbmVDaGFuZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIEVuZ2luZShjYW52YXMsIGNoYW5nZVNjZW5lc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjaGFuZ2VTY2VuZXMgY2FsbGJhY2sgaWYgZ2l2ZW5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlU2NlbmVzQ2FsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGNoYW5nZVNjZW5lc0NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTY2VuZXNDYWxsYmFjayA9IGNoYW5nZVNjZW5lc0NhbGxiYWNrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCBzY2VuZXNcbiAgICAgICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2NlbmVzID0ge307XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNhbnZhcyBhbmQgY29udGV4dFxuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIG1lLmdldFNjZW5lQWN0aXZlKCkuZXZlbnRGaXJlKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBtZS5nZXRTY2VuZUFjdGl2ZSgpLmV2ZW50RmlyZShldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIG1lLmdldFNjZW5lQWN0aXZlKCkuZXZlbnRGaXJlKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIG1lLmdldFNjZW5lQWN0aXZlKCkuZXZlbnRGaXJlKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgbWUuZ2V0U2NlbmVBY3RpdmUoKS5ldmVudEZpcmUoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIG1lLmdldFNjZW5lQWN0aXZlKCkuZXZlbnRGaXJlKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIG1lLmdldFNjZW5lQWN0aXZlKCkuZXZlbnRGaXJlKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIG1lLmdldFNjZW5lQWN0aXZlKCkuZXZlbnRGaXJlKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgbWUuZ2V0U2NlbmVBY3RpdmUoKS5ldmVudEZpcmUoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIGF0IGVhY2ggZnJhbWVcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihkdCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBjdXJyZW50IHNjZW5lXG4gICAgICAgICAgICB0aGlzLmdldFNjZW5lQWN0aXZlKCkucmVuZGVyKHRoaXMuY3R4LCBkdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHNjZW5lXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2NlbmVBZGQgPSBmdW5jdGlvbihzY2VuZSwgbmFtZSkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZXNbbmFtZV0gPSBzY2VuZTtcbiAgICAgICAgICAgIC8vIHRvbmd1ZSB0d2lzdGVyXG4gICAgICAgICAgICB0aGlzLnNjZW5lc1tuYW1lXS5uYW1lID0gbmFtZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZXN0cm95IGEgc2NlbmVcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zY2VuZURlc3Ryb3kgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zY2VuZXNbbmFtZV07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0cyB0aGUgYWN0aXZlIHNjZW5lXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ2V0U2NlbmVBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjZW5lc1t0aGlzLnNjZW5lQWN0aXZlXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGFuZ2VzIHRvIHRoZSBuZXcgc2NlbmVcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5jaGFuZ2VTY2VuZXMgPSBmdW5jdGlvbihzY2VuZU5hbWUsIFNjZW5lVHlwZSwgcHJlc2VydmVTZWxmKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGNoYW5nZSBzY2VuZXMgaWYgYSB2YWxpZCBzY2VuZU5hbWUgd2FzIGdpdmVuXG4gICAgICAgICAgICBpZiAoc2NlbmVOYW1lICE9PSBudWxsICYmIHNjZW5lTmFtZSAhPT0gdGhpcy5zY2VuZUFjdGl2ZSAmJiAhdGhpcy5zY2VuZUNoYW5naW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjZW5lQ3VycmVudCA9IHRoaXMuc2NlbmVBY3RpdmU7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2NlbmUgZG9lc24ndCBhbHJlYWR5IGV4aXN0IGFuZCBTY2VuZVR5cGUgd2FzIGdpdmVuLCBjcmVhdGUgaXRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2NlbmVzLmhhc093blByb3BlcnR5KHNjZW5lTmFtZSkgJiYgU2NlbmVUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVBZGQobmV3IFNjZW5lVHlwZSh0aGlzKSwgc2NlbmVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBldmVyeXRoaW5nIHdlbnQgd2VsbCwgY2hhbmdlIHNjZW5lc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lcy5oYXNPd25Qcm9wZXJ0eShzY2VuZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVDaGFuZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCA1MG1zIHRvIGF2b2lkICdmbGFzaCcgYmV0d2VlbiBzY2VuZXNcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zY2VuZUFjdGl2ZSA9IHNjZW5lTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVzdHJveSB0aGUgY3VycmVudCBzY2VuZSB1bmxlc3MgcHJlc2VydmVTZWxmXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByZXNlcnZlU2VsZiA9PT0gbnVsbCB8fCAhcHJlc2VydmVTZWxmKSAmJiBzY2VuZUN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5zY2VuZXNbc2NlbmVDdXJyZW50XS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIGlmIGl0IHdhcyBnaXZlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmNoYW5nZVNjZW5lc0NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuY2hhbmdlU2NlbmVzQ2FsbGJhY2sobWUuZ2V0U2NlbmVBY3RpdmUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNjZW5lQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRW5naW5lO1xuICAgIH0pKCk7XG59KSgpO1xuIiwiLypcbiAgICBFbnRpdHk6IFRleHQ6IEJ1dHRvblxuICAgIENyZWF0ZXMgYSB0ZXh0IG9iamVjdCB3aXRoIGFuIG91dGxpbmUgYXJvdW5kIGl0XG4qL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgU2NlbmUgPSByZXF1aXJlKCcuLi9zY2VuZScpO1xuICAgIHZhciBUZXh0ID0gcmVxdWlyZSgnLi4vZW50aXRpZXMvdGV4dCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFRleHQuZXh0ZW5kKEJ1dHRvbik7XG5cbiAgICAgICAgQnV0dG9uLnByb3RvdHlwZS5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgIEJ1dHRvbi5wcm90b3R5cGUuc2NlbmUgPSBudWxsO1xuICAgICAgICBCdXR0b24ucHJvdG90eXBlLmhlaWdodCA9IG51bGw7XG4gICAgICAgIEJ1dHRvbi5wcm90b3R5cGUucGFkZGluZyA9IDE2O1xuICAgICAgICBCdXR0b24ucHJvdG90eXBlLnN0cm9rZVN0eWxlID0gJ3JnYigwLCAwLCAwKSc7XG5cbiAgICAgICAgZnVuY3Rpb24gQnV0dG9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRleHQsIGZvbnQsIGZpbGxTdHlsZSwgY2FsbGJhY2ssIHBhZGRpbmcsIHN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgICBCdXR0b24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgeCwgeSwgd2lkdGgsIHRleHQsIGZvbnQsIGZpbGxTdHlsZSk7XG5cbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSB0byBwYXNzIGluIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhZGRpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Ryb2tlU3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgQnV0dG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihjdHgsIGR0KSB7XG4gICAgICAgICAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGhlaWdodCBvZiB0aGUgZm9udFxuICAgICAgICAgICAgdmFyIGZvbnRTaXplID0gcGFyc2VJbnQodGhpcy5mb250LnN1YnN0cigwLCB0aGlzLmZvbnQuaW5kZXhPZigncHgnKSkpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSB0ZXh0XG4gICAgICAgICAgICBpZiAodGhpcy5mb250ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsU3R5bGU7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCB0aGlzLnggKyB0aGlzLnBhZGRpbmcsIHRoaXMueSArIGZvbnRTaXplICsgdGhpcy5wYWRkaW5nLCB0aGlzLndpZHRoIC0gdGhpcy5wYWRkaW5nICogMik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQnV0dG9uIGNsaWNrIGV2ZW50LCBoYXMgdG8gY2hlY2sgaWYgY2xpY2sgd2FzIGluc2lkZSB0aGUgYnV0dG9uIVxuICAgICAgICBCdXR0b24ucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24oZXZlbnQsIHNjZW5lKSB7XG4gICAgICAgICAgICBpZiAoU2NlbmUuaXNJbnNpZGUoc2NlbmUuZ2V0RXZlbnRDb29yZHMoZXZlbnQpLCB0aGlzKSAmJiB0aGlzLmRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQnV0dG9uO1xuXG4gICAgfSkoKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBFbnRpdHkgPSByZXF1aXJlKCcuLi9lbnRpdHknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBFbnRpdHkuZXh0ZW5kKFNwcml0ZSk7XG5cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5vYmogPSBudWxsO1xuXG4gICAgICAgIC8vIFNwcml0ZVxuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnNwcml0ZVNoZWV0ID0gbnVsbDtcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5zcHJpdGVYID0gMDtcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5zcHJpdGVZID0gMDtcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5zcHJpdGVYRGVmYXVsdCA9IDA7XG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuc3ByaXRlWURlZmF1bHQgPSAwO1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBBbmltYXRpb25cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5zcHJpdGVBbmltYXRpb25zID0ge307XG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuc3ByaXRlQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5zcHJpdGVBbmltYXRpb25UaW1lID0gbnVsbDtcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5zcHJpdGVBbmltYXRpb25DYWxsYmFjayA9IG51bGw7XG5cbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlKHgsIHksIHdpZHRoLCBoZWlnaHQsIHNwcml0ZVNoZWV0LCBzcHJpdGVYLCBzcHJpdGVZLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0KSB7XG4gICAgICAgICAgICBTcHJpdGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcHJpdGVYID09PSAndW5kZWZpbmVkJyB8fCBzcHJpdGVYID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVYID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlWCA9IHNwcml0ZVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwcml0ZVkgPT09ICd1bmRlZmluZWQnIHx8IHNwcml0ZVkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZVkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVZID0gc3ByaXRlWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ByaXRlV2lkdGggPT09ICd1bmRlZmluZWQnIHx8IHNwcml0ZVdpZHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVXaWR0aCA9IHNwcml0ZVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcHJpdGVIZWlnaHQgPT09ICd1bmRlZmluZWQnIHx8IHNwcml0ZUhlaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVIZWlnaHQgPSBzcHJpdGVIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3ByaXRlWERlZmF1bHQgPSB0aGlzLnNwcml0ZVg7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZVlEZWZhdWx0ID0gdGhpcy5zcHJpdGVZO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG9iamVjdFxuICAgICAgICAgICAgdGhpcy5vYmogPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICAgICAgLy8gTG9hZCBpdCdzIHJlc291cmNlXG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5vYmouYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMub2JqLnNyYyA9IHRoaXMuc3ByaXRlU2hlZXQ7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBSZXNldCBvYmplY3RzIChmb3IgYSBkZWVwIGNvcHkpXG4gICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgdGhlIGVudGl0eSBpbiB0aGUgZ2l2ZW4gY29udGV4dCBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXNcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihjdHgsIGR0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGluZykge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBzcHJpdGUgYW5pbWF0aW9ucyBpZiBuZWVkZWQgZm9yIG5leHQgZnJhbWVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zcHJpdGVBbmltYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb25UaW1lICs9IGR0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5zcHJpdGVBbmltYXRpb25zW3RoaXMuc3ByaXRlQW5pbWF0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lc0xlbmd0aCA9IGFuaW1hdGlvbi50b1ggLSBhbmltYXRpb24uZnJvbVggKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhbmltYXRpb24gaGFzIGVuZGVkLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNwcml0ZUFuaW1hdGlvblRpbWUgPiBhbmltYXRpb24ucGVyaW9kICogZnJhbWVzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgc2V0IG51bWJlciBvZiByZXBldGl0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ByaXRlQW5pbWF0aW9uUmVwZXRpdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb25SZXBldGl0aW9ucy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGZpbmlzaGVkIGFuaW1hdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNwcml0ZUFuaW1hdGlvblJlcGV0aXRpb25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zcHJpdGVBbmltYXRpb25DYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb25DYWxsYmFjayh7dHlwZTogJ3Nwcml0ZUFuaW1hdGlvbkVuZCd9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvblRpbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbkNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVYID0gdGhpcy5zcHJpdGVYRGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVZID0gdGhpcy5zcHJpdGVZRGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb25UaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBtYWtlIHN1cmUgdGhlIGN1cnJlbnQgZnJhbWUgaXMgY29ycmVjdFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IE1hdGguZmxvb3IodGhpcy5zcHJpdGVBbmltYXRpb25UaW1lIC8gYW5pbWF0aW9uLnBlcmlvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZVggPSBhbmltYXRpb24uZnJvbVggKyBmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlWSA9IGFuaW1hdGlvbi5mcm9tWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgaW1hZ2Ugb24gdGhlIHNjZW5lXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLm9iajtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gdGhpcy5zcHJpdGVYICogdGhpcy5zcHJpdGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gdGhpcy5zcHJpdGVZICogdGhpcy5zcHJpdGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzV2lkdGggPSB0aGlzLnNwcml0ZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc0hlaWdodCA9IHRoaXMuc3ByaXRlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LCBkeCwgZHksIGRXaWR0aCwgZEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERlZmluZSBhIG5ldyBzcHJpdGUgYW5pbWF0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWVzIGFuZCBmcmFtZXMgaW4gdGhlIHNwcml0ZSBzaGVldFxuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnNwcml0ZUFuaW1hdGlvbkFkZCA9IGZ1bmN0aW9uKG5hbWUsIGZyb21YLCBmcm9tWSwgdG9YLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uc1tuYW1lXSA9IHtmcm9tWDogZnJvbVgsIGZyb21ZOiBmcm9tWSwgdG9YOiB0b1gsIHBlcmlvZDogcGVyaW9kfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSdW4gYW4gYW5pbWF0aW9uXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuc3ByaXRlQW5pbWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIHJlcGV0aXRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVwZXRpdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXBldGl0aW9ucyA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb25SZXBldGl0aW9ucyA9IHJlcGV0aXRpb25zO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24gPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb25UaW1lID0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTdG9wIHRoZSBydW5uaW5nIGFuaW1hdGlvblxuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnNwcml0ZUFuaW1hdGVTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvblRpbWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVYID0gdGhpcy5zcHJpdGVYRGVmYXVsdDtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlWSA9IHRoaXMuc3ByaXRlWURlZmF1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFNwcml0ZTtcblxuICAgIH0pKCk7XG59KSgpO1xuIiwiLypcbiAgICBFbnRpdHk6IFRleHRcbiAgICBDcmVhdGVzIGEgdGV4dCBvYmplY3RcbiovXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBFbnRpdHkgPSByZXF1aXJlKCcuLi9lbnRpdHknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBFbnRpdHkuZXh0ZW5kKFRleHQpO1xuXG4gICAgICAgIFRleHQucHJvdG90eXBlLnRleHQgPSAnJztcbiAgICAgICAgVGV4dC5wcm90b3R5cGUuZm9udCA9IG51bGw7XG4gICAgICAgIFRleHQucHJvdG90eXBlLmZpbGxTdHlsZSA9ICdyZ2IoMCwgMCwgMCknO1xuICAgICAgICBUZXh0LnByb3RvdHlwZS50ZXh0QWxpZ24gPSAnbGVmdCc7XG5cbiAgICAgICAgZnVuY3Rpb24gVGV4dCh4LCB5LCB3aWR0aCwgdGV4dCwgZm9udCwgZmlsbFN0eWxlLCB0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb250ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbGxTdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dEFsaWduICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVGV4dC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCB4LCB5LCB3aWR0aCwgdGhpcy5oZWlnaHQgfHwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBUZXh0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihjdHgsIGR0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb250ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsU3R5bGU7XG5cbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnRleHQsIHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVGV4dDtcblxuICAgIH0pKCk7XG59KSgpO1xuIiwiLypcbiAgICBFbnRpdHk6IFRleHQ6IFRleHRJbnB1dFxuICAgIE1pbWljcyBhbiA8aW5wdXQ+IGluIERPTVxuKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFRleHQgPSByZXF1aXJlKCcuL3RleHQnKTtcbiAgICB2YXIgU2NlbmUgPSByZXF1aXJlKCcuLi9zY2VuZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFRleHQuZXh0ZW5kKFRleHRJbnB1dCk7XG5cbiAgICAgICAgVGV4dElucHV0LnByb3RvdHlwZS5oZWlnaHQgPSAwO1xuICAgICAgICBUZXh0SW5wdXQucHJvdG90eXBlLmZvbnQgPSBudWxsO1xuICAgICAgICBUZXh0SW5wdXQucHJvdG90eXBlLmZpbGxTdHlsZUlucHV0ID0gJ3JnYigyNTUsIDI1NSwgMjU1KSc7XG4gICAgICAgIFRleHRJbnB1dC5wcm90b3R5cGUuc3Ryb2tlU3R5bGUgPSAncmdiKDI1NSwgMjU1LCAyNTUpJztcbiAgICAgICAgVGV4dElucHV0LnByb3RvdHlwZS5wYWRkaW5nID0gODtcblxuICAgICAgICAvLyBIaWRkZW4gRE9NIGlucHV0XG4gICAgICAgIFRleHRJbnB1dC5wcm90b3R5cGUuaW5wdXQgPSBudWxsO1xuICAgICAgICBUZXh0SW5wdXQucHJvdG90eXBlLmN1cnNvciA9IG51bGw7XG4gICAgICAgIFRleHRJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmYWxzZTtcbiAgICAgICAgVGV4dElucHV0LnByb3RvdHlwZS50eXBlID0gJ3RleHQnO1xuXG4gICAgICAgIGZ1bmN0aW9uIFRleHRJbnB1dCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0ZXh0LCBmb250LCBmaWxsU3R5bGUsIHRleHRBbGlnbiwgc3Ryb2tlU3R5bGUsIHBhZGRpbmcsIGZpbGxTdHlsZUlucHV0LCB0eXBlKSB7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvbnQpIHtcbiAgICAgICAgICAgICAgICBmb250ID0gdGhpcy5mb250O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaWxsU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGUgPSB0aGlzLmZpbGxTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJva2VTdHlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxsU3R5bGVJbnB1dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbFN0eWxlSW5wdXQgPSBmaWxsU3R5bGVJbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVGV4dElucHV0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHgsIHksIHdpZHRoLCB0ZXh0LCBmb250LCBmaWxsU3R5bGUsIHRleHRBbGlnbik7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgaGlkZGVuIGlucHV0XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuc3R5bGUudG9wID0gJy0xMDAwMHB4JztcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuc3R5bGVbJ3otaW5kZXgnXSA9IC0xO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmlucHV0KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IHRvIHB1bGwgdGV4dCBmcm9tIGhpZGRlbiBpbnB1dFxuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIG1lLnRleHQgPSBtZS5pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgVGV4dElucHV0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihjdHgsIGR0KSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGhlaWdodCBvZiB0aGUgZm9udFxuICAgICAgICAgICAgdmFyIGZvbnRTaXplID0gcGFyc2VJbnQodGhpcy5mb250LnN1YnN0cigwLCB0aGlzLmZvbnQuaW5kZXhPZigncHgnKSkpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGxTdHlsZUlucHV0O1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgdGV4dFxuICAgICAgICAgICAgaWYgKHRoaXMuZm9udCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5mb250O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZmlsbFN0eWxlO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgdGhpcy54ICsgdGhpcy5wYWRkaW5nLCB0aGlzLnkgKyBmb250U2l6ZSArIHRoaXMucGFkZGluZywgdGhpcy53aWR0aCAtIHRoaXMucGFkZGluZyAqIDIpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGN1cnNvclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QodGhpcy54ICsgNCwgdGhpcy55ICsgMiwgMiwgdGhpcy5oZWlnaHQgLSA0KTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5wdXQgY2xpY2sgZXZlbnQsIGhhbmRsZSBmb2N1c1xuICAgICAgICBUZXh0SW5wdXQucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24oZXZlbnQsIHNjZW5lKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2xpY2sgd2FzIGluIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBpZiAoU2NlbmUuaXNJbnNpZGUoc2NlbmUuZ2V0RXZlbnRDb29yZHMoZXZlbnQpLCB0aGlzKSAmJiB0aGlzLmRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGZvY3VzIG9uIHRoZSBoaWRkZW4gaW5wdXRcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHJlbW92ZSB0aGUgdmlzdWFsIGZvY3VzIGVsZW1lbnRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVGV4dElucHV0O1xuXG4gICAgfSkoKTtcbn0pKCk7XG4iLCIvKlxuICAgIEVudGl0eTogVGV4dE11bHRpbGluZVxuICAgIENyZWF0ZXMgYSB0ZXh0IG9iamVjdFxuKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFRleHQgPSByZXF1aXJlKCcuL3RleHQnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBUZXh0LmV4dGVuZChUZXh0TXVsdGlsaW5lKTtcblxuICAgICAgICBUZXh0TXVsdGlsaW5lLnByb3RvdHlwZS5jaGFyc1BlckxpbmUgPSA4MDtcbiAgICAgICAgVGV4dE11bHRpbGluZS5wcm90b3R5cGUubGluZUhlaWdodCA9IDMwO1xuXG4gICAgICAgIC8vIFRoZSB0ZXh0IHNwbGl0IGludG8gbGluZXNcbiAgICAgICAgVGV4dE11bHRpbGluZS5wcm90b3R5cGUudGV4dEFycmF5ID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gVGV4dE11bHRpbGluZSh4LCB5LCB3aWR0aCwgdGV4dCwgZm9udCwgZmlsbFN0eWxlLCBjaGFyc1BlckxpbmUsIGxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IHRleHRBcnJheSBmb3IgYSBkZWVwIGNvcHlcbiAgICAgICAgICAgIHRoaXMudGV4dEFycmF5ID0gW107XG5cbiAgICAgICAgICAgIFRleHRNdWx0aWxpbmUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgeCwgeSwgd2lkdGgsIHRleHQsIGZvbnQsIGZpbGxTdHlsZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhcnNQZXJMaW5lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnNQZXJMaW5lID0gY2hhcnNQZXJMaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaW5lSGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgdGV4dCBhcnJheVxuICAgICAgICAgICAgdmFyIHRleHRXb3JkcyA9IHRoaXMudGV4dC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHRleHRXb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRBcnJheVtsaW5lXSA9IHRleHRXb3Jkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnRleHRBcnJheVtsaW5lXSAmJiAodHlwZW9mIHRleHRXb3Jkc1swXSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0aGlzLnRleHRBcnJheVtsaW5lXSArIHRleHRXb3Jkc1swXSkubGVuZ3RoIDwgdGhpcy5jaGFyc1BlckxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0QXJyYXlbbGluZV0gKz0gJyAnICsgdGV4dFdvcmRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFRleHRNdWx0aWxpbmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCwgZHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuZm9udDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGxTdHlsZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRleHRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnRleHRBcnJheVtpXSwgdGhpcy54LCB0aGlzLnkgKyBpICogdGhpcy5saW5lSGVpZ2h0LCB0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVGV4dE11bHRpbGluZTtcblxuICAgIH0pKCk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRXh0ZW5kYWJsZSA9IHJlcXVpcmUoJy4vZXh0ZW5kYWJsZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEluaGVyaXQgZnJvbSB0aGUgRXh0ZW5kYWJsZSBjbGFzc1xuICAgICAgICBFeHRlbmRhYmxlLmV4dGVuZChFbnRpdHkpO1xuXG4gICAgICAgIC8vIENhbnZhcyBSZW5kZXJpbmdcbiAgICAgICAgRW50aXR5LnByb3RvdHlwZS5kaXNwbGF5ID0gdHJ1ZTtcbiAgICAgICAgRW50aXR5LnByb3RvdHlwZS54ID0gMDtcbiAgICAgICAgRW50aXR5LnByb3RvdHlwZS55ID0gMDtcbiAgICAgICAgRW50aXR5LnByb3RvdHlwZS53aWR0aCA9IDA7XG4gICAgICAgIEVudGl0eS5wcm90b3R5cGUuaGVpZ2h0ID0gMDtcbiAgICAgICAgRW50aXR5LnByb3RvdHlwZS5jb2xvciA9ICdyZ2IoMCwgMCwgMCknO1xuXG4gICAgICAgIC8vIENvbXBvbmVudHNcbiAgICAgICAgRW50aXR5LnByb3RvdHlwZS5jb21wb25lbnRzID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gRW50aXR5KHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG4gICAgICAgICAgICAvLyBTZXQgcGFzc2VkIGluIGFyZ3NcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAoY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IG9iamVjdHMgKGZvciBhIGRlZXAgY29weSlcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgZW50aXR5IGluIHRoZSBnaXZlbiBjb250ZXh0IGF0IHRoZSBnaXZlbiBjb29yZGluYXRlc1xuICAgICAgICBFbnRpdHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCwgZHQpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIGEgY29tcG9uZW50XG4gICAgICAgIEVudGl0eS5wcm90b3R5cGUuY29tcG9uZW50QWRkID0gZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50Lm5hbWVdID0gY29tcG9uZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlbW92ZSBhIGNvbXBvbmVudFxuICAgICAgICBFbnRpdHkucHJvdG90eXBlLmNvbXBvbmVudFJlbW92ZSA9IGZ1bmN0aW9uKENvbXBvbmVudCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29tcG9uZW50c1tDb21wb25lbnQudGl0bGVdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBFbnRpdHk7XG5cbiAgICB9KSgpO1xufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gRXh0ZW5kYWJsZSgpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZ2l2ZW4gY2hpbGQgYXMgYSBzdWJjbGFzcyBvZiB0aGUgcGFyZW50IGNsYXNzXG4gICAgICAgIEV4dGVuZGFibGUuZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFtrZXldID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gQ3RvcigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDdG9yLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlID0gbmV3IEN0b3IoKTtcblxuICAgICAgICAgICAgY2hpbGQuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEV4dGVuZGFibGU7XG5cbiAgICB9KSgpO1xufSkoKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRW5naW5lID0gcmVxdWlyZSgnLi9lbmdpbmUnKTtcbiAgICB2YXIgRW50aXR5ID0gcmVxdWlyZSgnLi9lbnRpdHknKTtcbiAgICB2YXIgRXh0ZW5kYWJsZSA9IHJlcXVpcmUoJy4vZXh0ZW5kYWJsZScpO1xuICAgIHZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudCcpO1xuICAgIHZhciBTY2VuZSA9IHJlcXVpcmUoJy4vc2NlbmUnKTtcbiAgICB2YXIgTG9hZGluZyA9IHJlcXVpcmUoJy4vc2NlbmVzL2xvYWRpbmcnKTtcbiAgICB2YXIgU3ByaXRlID0gcmVxdWlyZSgnLi9lbnRpdGllcy9zcHJpdGUnKTtcbiAgICB2YXIgVGV4dCA9IHJlcXVpcmUoJy4vZW50aXRpZXMvdGV4dCcpO1xuICAgIHZhciBUZXh0TXVsdGlsaW5lID0gcmVxdWlyZSgnLi9lbnRpdGllcy90ZXh0TXVsdGlsaW5lJyk7XG4gICAgdmFyIFRleHRJbnB1dCA9IHJlcXVpcmUoJy4vZW50aXRpZXMvdGV4dElucHV0Jyk7XG4gICAgdmFyIEJ1dHRvbiA9IHJlcXVpcmUoJy4vZW50aXRpZXMvYnV0dG9uJyk7XG4gICAgdmFyIFR3ZWVuID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL3R3ZWVuJyk7XG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9kcmFnZ2FibGUnKTtcbiAgICB2YXIgRHJhZ0NyZWF0ZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9kcmFnQ3JlYXRlJyk7XG4gICAgdmFyIEtleU1vdmUgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMva2V5TW92ZScpO1xuICAgIHZhciBCb3VuZGVkID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2JvdW5kZWQnKTtcbiAgICB2YXIgQ29sbGlzaW9uID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2NvbGxpc2lvbicpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBnbG9iYWwgaG9vcHR5IG9iamVjdFxuICAgIHdpbmRvdy5ob29wdHkgPSB7XG4gICAgICAgIEVuZ2luZTogRW5naW5lLFxuICAgICAgICBFeHRlbmRhYmxlOiBFeHRlbmRhYmxlLFxuICAgICAgICBlbnRpdGllczoge1xuICAgICAgICAgICAgRW50aXR5OiBFbnRpdHksXG4gICAgICAgICAgICBTcHJpdGU6IFNwcml0ZSxcbiAgICAgICAgICAgIFRleHQ6IFRleHQsXG4gICAgICAgICAgICBUZXh0TXVsdGlsaW5lOiBUZXh0TXVsdGlsaW5lLFxuICAgICAgICAgICAgVGV4dElucHV0OiBUZXh0SW5wdXQsXG4gICAgICAgICAgICBCdXR0b246IEJ1dHRvbixcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgICAgICAgICBCb3VuZGVkOiBCb3VuZGVkLFxuICAgICAgICAgICAgQ29sbGlzaW9uOiBDb2xsaXNpb24sXG4gICAgICAgICAgICBEcmFnZ2FibGU6IERyYWdnYWJsZSxcbiAgICAgICAgICAgIERyYWdDcmVhdGU6IERyYWdDcmVhdGUsXG4gICAgICAgICAgICBLZXlNb3ZlOiBLZXlNb3ZlLFxuICAgICAgICAgICAgVHdlZW46IFR3ZWVuLFxuICAgICAgICB9LFxuICAgICAgICBzY2VuZXM6IHtcbiAgICAgICAgICAgIFNjZW5lOiBTY2VuZSxcbiAgICAgICAgICAgIExvYWRpbmc6IExvYWRpbmcsXG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEV4dGVuZGFibGUgPSByZXF1aXJlKCcuL2V4dGVuZGFibGUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJbmhlcml0IGZyb20gdGhlIEV4dGVuZGFibGUgY2xhc3NcbiAgICAgICAgRXh0ZW5kYWJsZS5leHRlbmQoU2NlbmUpO1xuXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yb3V0ZSA9ICcvJztcblxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZW50aXRpZXMgPSBbXTtcblxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZW5naW5lID0gbnVsbDtcblxuICAgICAgICAvLyBVc2VkIGJ5IHRoZSBkcmFnZ2FibGUgY29tcG9uZW50IHRvIGxpbWl0IGRyYWdnaW5nIHRvIDEgZW50aXR5IGF0IGEgdGltZVxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBTY2VuZShlbmdpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZW50aXRpZXMgb2JqZWN0XG4gICAgICAgICAgICB0aGlzLmVudGl0aWVzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IHRoZSBlbnRpdHkgaW4gdGhlIGdpdmVuIGNvbnRleHQgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihjdHgsIGR0KSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN0eFxuICAgICAgICAgICAgdGhpcy5jdHggPSBjdHg7XG5cbiAgICAgICAgICAgIC8vIFJlbmRlciBlbnRpdGllc1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZW50aXRpZXMuZm9yRWFjaChmdW5jdGlvbihlbHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWx0LmRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZXZlbnRGaXJlKHt0eXBlOiAncHJlUmVuZGVyJywgZHQ6IGR0fSk7XG4gICAgICAgICAgICAgICAgICAgIGVsdC5yZW5kZXIoY3R4LCBkdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGVudGl0eVxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZW50aXR5QWRkID0gZnVuY3Rpb24oZW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudGl0aWVzW3RoaXMuZW50aXRpZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFuIGVudGl0eS4gIFJldHVybnMgdHJ1ZSBpZiBmb3VuZCwgZmFsc2UgaWYgbm90IGZvdW5kXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5lbnRpdHlSZW1vdmUgPSBmdW5jdGlvbihlbnRpdHkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5lbnRpdGllcykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRpdHlDaGVjayA9IHRoaXMuZW50aXRpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVudGl0eUNoZWNrID09PSBlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRpdGllcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGwgdGhlIGdpdmVuIGV2ZW50IHJlc3BvbmRlciBvbiBhbGwgZW50aXR5IGNvbXBvbmVudHMgbGlzdGVuaW5nXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5ldmVudEZpcmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgLy8gRmlyZSBvbiB0aGUgc2NlbmVcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2V2ZW50LnR5cGVdKGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGluIHJldmVyc2Ugb3JkZXIsIHRvIGZpcmUgb24gcmVjZW50LCB0b3AgZW50aXRpZXMgZmlyc3RcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmVudGl0aWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZSBvbiBhbGwgZW50aXRpZXNcbiAgICAgICAgICAgICAgICB2YXIgZW50aXR5ID0gdGhpcy5lbnRpdGllc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSBpbiBlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5W2V2ZW50LnR5cGVdKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBlbnRpdHkuY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIG9uIGFsbCBjb21wb25lbnRzIG9uIHRoZSBnaXZlbiBlbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGVudGl0eS5jb21wb25lbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSBpbiBjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFtldmVudC50eXBlXShldmVudCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0cyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZXZlbnQgb24gdGhlIGNhbnZhcyByZWxhdGl2ZSB0byB0aGUgY2FudmFzXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5nZXRFdmVudENvb3JkcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBPbmx5IGlmIHdlIGhhdmUgY3R4IChoYXZlIHJlbmRlcmVkKVxuICAgICAgICAgICAgaWYgKCdjdHgnIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxPZmZzZXRYID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxPZmZzZXRZID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzWCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc1kgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IHRoaXMuY3R4LmNhbnZhcztcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGlyZWN0IGV2ZW50IHgveVxuICAgICAgICAgICAgICAgIHZhciBldmVudFggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBldmVudFkgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJyB8fCBldmVudC50eXBlID09PSAndG91Y2hjYW5jZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE9yaWdpbmFsID0gZXZlbnQudG91Y2hlc1swXSB8fCBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRYID0gZXZlbnRPcmlnaW5hbC5wYWdlWDtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRZID0gZXZlbnRPcmlnaW5hbC5wYWdlWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50WCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgICAgICAgICBldmVudFkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNvb3JkcyB3aXRoIHJlc3BlY3QgdG8gdGhlIGNhbnZhc1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxPZmZzZXRYICs9IGN1cnJlbnRFbGVtZW50Lm9mZnNldExlZnQgLSBjdXJyZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB0b3RhbE9mZnNldFkgKz0gY3VycmVudEVsZW1lbnQub2Zmc2V0VG9wIC0gY3VycmVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZShjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50Lm9mZnNldFBhcmVudCk7XG5cbiAgICAgICAgICAgICAgICBjYW52YXNYID0gZXZlbnRYIC0gdG90YWxPZmZzZXRYO1xuICAgICAgICAgICAgICAgIGNhbnZhc1kgPSBldmVudFkgLSB0b3RhbE9mZnNldFk7XG5cbiAgICAgICAgICAgICAgICAvLyBTY2FsZSB0aGUgY29vcmRzIGlmIHRoZSBjYW52YXMgaXMgc2NhbGVkXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5jdHguY2FudmFzLndpZHRoIC8gdGhpcy5jdHguY2FudmFzLnN0eWxlLndpZHRoLnN1YnN0cigwLCB0aGlzLmN0eC5jYW52YXMuc3R5bGUud2lkdGgubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgY2FudmFzWCAqPSBzY2FsZTtcbiAgICAgICAgICAgICAgICBjYW52YXNZICo9IHNjYWxlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt4OmNhbnZhc1gsIHk6Y2FudmFzWX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3g6IDAsIHk6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29vcmRzIGFyZSBpbnNpZGUgdGhlIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgIFNjZW5lLmlzSW5zaWRlID0gZnVuY3Rpb24oY29vcmRzLCBlbnRpdHkpIHtcbiAgICAgICAgICAgIGlmICgoY29vcmRzLnggPj0gZW50aXR5LngpICYmIChjb29yZHMueCA8PSBlbnRpdHkueCArIGVudGl0eS53aWR0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGNvb3Jkcy55ID49IGVudGl0eS55KSAmJiAoY29vcmRzLnkgPD0gZW50aXR5LnkgKyBlbnRpdHkuaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gZW50aXRpZXMgb3ZlcmxhcFxuICAgICAgICBTY2VuZS5pc092ZXJsYXAgPSBmdW5jdGlvbihlbnRpdHkxLCBlbnRpdHkyKSB7XG4gICAgICAgICAgICB2YXIgcmVjdDFYMSA9IGVudGl0eTEueDtcbiAgICAgICAgICAgIHZhciByZWN0MVgyID0gZW50aXR5MS54ICsgZW50aXR5MS53aWR0aDtcbiAgICAgICAgICAgIHZhciByZWN0MVkxID0gZW50aXR5MS55O1xuICAgICAgICAgICAgdmFyIHJlY3QxWTIgPSBlbnRpdHkxLnkgKyBlbnRpdHkxLmhlaWdodDtcbiAgICAgICAgICAgIHZhciByZWN0MlgxID0gZW50aXR5Mi54O1xuICAgICAgICAgICAgdmFyIHJlY3QyWDIgPSBlbnRpdHkyLnggKyBlbnRpdHkyLndpZHRoO1xuICAgICAgICAgICAgdmFyIHJlY3QyWTEgPSBlbnRpdHkyLnk7XG4gICAgICAgICAgICB2YXIgcmVjdDJZMiA9IGVudGl0eTIueSArIGVudGl0eTIuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAocmVjdDFYMSA8IHJlY3QyWDIgJiYgcmVjdDFYMiA+IHJlY3QyWDEgJiYgcmVjdDFZMSA8IHJlY3QyWTIgJiYgcmVjdDFZMiA+IHJlY3QyWTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHggYW5kIHkgc2V0IHRvIHRoZSBtaWRwb2ludCBvZiB0aGUgdHdvIGVudGl0aWVzXG4gICAgICAgIFNjZW5lLmdldE1pZHBvaW50ID0gZnVuY3Rpb24oZW50aXR5MSwgZW50aXR5Mikge1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHt4OiAwLCB5OiAwfTtcblxuICAgICAgICAgICAgY29vcmRzLnggPSBNYXRoLnJvdW5kKChlbnRpdHkxLnggKyBlbnRpdHkyLngpIC8gMik7XG4gICAgICAgICAgICBjb29yZHMueSA9IE1hdGgucm91bmQoKGVudGl0eTEueSArIGVudGl0eTIueSkgLyAyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXNldCB0aGUgY3VycmVudCBzY2VuZVxuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnNjZW5lc1t0aGlzLm5hbWVdID0gbmV3IFNjZW5lKHRoaXMuZW5naW5lKTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmNoYW5nZVNjZW5lcyh0aGlzLm5hbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERlc3Ryb3kgdGhpcyBzY2VuZSBieSByZW1vdmluZyBpdHMgcmVmcmVuY2UgaW4gZW5naW5lXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5zY2VuZURlc3Ryb3kodGhpcy5uYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gU2NlbmU7XG5cbiAgICB9KSgpO1xufSkoKTtcbiIsIi8qXG4gICAgU2NlbmU6IExvYWRpbmdcbiAgICBUaGUgaW5pdGlhbCBsb2FkaW5nIHNjcmVlblxuKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFNjZW5lID0gcmVxdWlyZSgnLi4vc2NlbmUnKTtcbiAgICB2YXIgVGV4dCA9IHJlcXVpcmUoJy4uL2VudGl0aWVzL3RleHQnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBTY2VuZS5leHRlbmQoTG9hZGluZyk7XG5cbiAgICAgICAgTG9hZGluZy5wcm90b3R5cGUubmFtZSA9ICdMb2FkaW5nJztcblxuICAgICAgICAvLyBUaGUgc2NlbmUgdG8gY2hhbmdlIHRvIHdoZW4gbG9hZGluZyBpcyBkb25lXG4gICAgICAgIExvYWRpbmcucHJvdG90eXBlLnNjZW5lTmFtZUNoYW5nZVRvID0gJ1N0YXJ0JztcblxuICAgICAgICBMb2FkaW5nLnByb3RvdHlwZS51cmxDb3VudCA9IDA7XG4gICAgICAgIExvYWRpbmcucHJvdG90eXBlLnVybHNEb25lID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBMb2FkaW5nKGVuZ2luZSwgdXJscywgc2NlbmVOYW1lQ2hhbmdlVG8pIHtcbiAgICAgICAgICAgIGlmIChzY2VuZU5hbWVDaGFuZ2VUbykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVOYW1lQ2hhbmdlVG8gPSBzY2VuZU5hbWVDaGFuZ2VUbztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTG9hZGluZy5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbmdpbmUpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHVybCBjb3VudFxuICAgICAgICAgICAgaWYgKCF1cmxzKSB7XG4gICAgICAgICAgICAgICAgdXJscyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cmxDb3VudCA9IHVybHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRpdGxlXG4gICAgICAgICAgICB0aGlzLmVudGl0eUFkZChuZXcgVGV4dCh0aGlzLmVuZ2luZS5jdHguY2FudmFzLndpZHRoIC8gNCwgMjYwLCAwLCAnTG9hZGluZy4uLicsICc1MHB4IFxcJ1ByZXNzIFN0YXJ0IDJQXFwnJywgJ3JnYigwLCAwLCAwKScpKTtcblxuICAgICAgICAgICAgLy8gTG9hZCBlYWNoIHVybFxuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIHVybHMuZm9yRWFjaChmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVybHNEb25lKys7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgTG9hZGluZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oY3R4LCBkdCkge1xuICAgICAgICAgICAgLy8gR28gdG8gbmV4dCBzY2VuZSBpZiBhbGwgbG9hZGVkXG4gICAgICAgICAgICBpZiAodGhpcy51cmxzRG9uZSA+PSB0aGlzLnVybENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUuY2hhbmdlU2NlbmVzKHRoaXMuc2NlbmVOYW1lQ2hhbmdlVG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGJhY2tncm91bmRcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiKDI1NSwgMjU1LCAyNTUpJztcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCAoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICBMb2FkaW5nLl9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzLCBjdHgsIGR0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gTG9hZGluZztcblxuICAgIH0pKCk7XG59KSgpO1xuIl19
